{
  "version": 3,
  "sources": ["../src/beamtrace2d.ts", "../src/main.ts"],
  "sourcesContent": ["/****\n * BeamTrace2D v 2.0\n *\n * =======\n *\n * Copyright (C) 2014 Kai Saksela. Based on the very basic principles of beam tracing as presented in \"Accelerated beam tracing algorithm\" by S. Laine, S. Siltanen, T. Lokki, and L. Savioja.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * TLDR; Feel free to play with the code, as long as you mention this copyright notice if you publish it somewhere.\n *\n * =======\n *\n * This code is for testing different beam tracing techniques in a simplified 2D environment.\n * - BSP trees (in this case the splitting planes are not aligned) for accelerated ray tracing\n * - Beam trees with polygon ID's\n * - The optimization techniques are absent in this version, so it's not nearly as fast as it would be with them\n *\n */\n\n/** 2D point as [x, y] tuple */\nexport type Point = [number, number];\n\n/** Path point with reflection info [x, y, wallId] where wallId is null for source/listener */\nexport type PathPoint = [number, number, number | null];\n\n/** Complete reflection path from listener to source */\nexport type ReflectionPath = PathPoint[];\n\n/** Line intersection result array: [x, y, onLine1, onLine2, onRay1, onRay2, wallId?] */\ntype IntersectionResult = [number, number, boolean, boolean, boolean, boolean, number?] | null;\n\n/** Wall segment defined by two endpoints */\nexport class Wall {\n  constructor(\n    public p1: Point,\n    public p2: Point\n  ) {}\n\n  draw(ctx: CanvasRenderingContext2D): void {\n    ctx.beginPath();\n    ctx.moveTo(this.p1[0], this.p1[1]);\n    ctx.lineTo(this.p2[0], this.p2[1]);\n    ctx.stroke();\n  }\n}\n\n/** Listener position */\nexport class Listener {\n  constructor(public p0: Point) {}\n\n  draw(ctx: CanvasRenderingContext2D): void {\n    const oldFill = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.arc(this.p0[0], this.p0[1], 10, 0, 2 * Math.PI);\n    ctx.fillStyle = 'yellow';\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = oldFill;\n  }\n}\n\n/** Sound source position */\nexport class Source {\n  constructor(public p0: Point) {}\n\n  draw(ctx: CanvasRenderingContext2D): void {\n    const oldFill = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.arc(this.p0[0], this.p0[1], 10, 0, 2 * Math.PI);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    ctx.stroke();\n    ctx.fillStyle = oldFill;\n  }\n}\n\n/** BSP tree node for spatial partitioning */\nclass BSPNode {\n  front: BSPNode | null = null;\n  back: BSPNode | null = null;\n\n  constructor(\n    public id: number,\n    public p1: Point,\n    public p2: Point\n  ) {}\n}\n\n/** Beam in 2D space with virtual source and window points */\nclass Beam {\n  constructor(\n    public vs: Point,  // Virtual source point\n    public p1: Point,  // Window point 1\n    public p2: Point   // Window point 2\n  ) {}\n}\n\n/** Node in the beam tree */\nclass BeamNode {\n  children: BeamNode[] = [];\n\n  // Optimization fields for fail line caching\n  failLine?: import('./geometry').Line2D;\n  failLineType?: import('./geometry').FailLineType;\n\n  constructor(\n    public id: number,\n    public parent: BeamNode | null,\n    public vs: Point\n  ) {}\n\n  /** Clear cached fail line (called when listener escapes the fail region) */\n  clearFailLine(): void {\n    this.failLine = undefined;\n    this.failLineType = undefined;\n  }\n}\n\n/** BSP tree for accelerated ray-wall intersection tests */\nclass BSPTree {\n  mainNode: BSPNode | null;\n\n  constructor(walls: Wall[]) {\n    const recursiveArray: BSPNode[] = [];\n    for (let i = 0; i < walls.length; i++) {\n      recursiveArray.push(new BSPNode(i, walls[i].p1, walls[i].p2));\n    }\n    this.mainNode = this.build(recursiveArray);\n  }\n\n  private build(recursiveArray: BSPNode[]): BSPNode | null {\n    if (recursiveArray.length === 0) {\n      return null;\n    }\n\n    while (recursiveArray.length > 1) {\n      const node = recursiveArray.pop()!;\n      const retval = this.divide(recursiveArray[0], node);\n\n      if (retval === 1) {\n        // In front\n        recursiveArray[0].front = this.insertNode(\n          recursiveArray[0].front,\n          new BSPNode(node.id, node.p1, node.p2)\n        );\n      } else if (retval === -1) {\n        // Behind\n        recursiveArray[0].back = this.insertNode(\n          recursiveArray[0].back,\n          new BSPNode(node.id, node.p1, node.p2)\n        );\n      } else {\n        // Split into two - retval is a tuple\n        const splitResult = retval as [{ p1: Point; p2: Point }, { p1: Point; p2: Point }];\n        recursiveArray[0].front = this.insertNode(\n          recursiveArray[0].front,\n          new BSPNode(node.id, splitResult[0].p1, splitResult[0].p2)\n        );\n        recursiveArray[0].back = this.insertNode(\n          recursiveArray[0].back,\n          new BSPNode(node.id, splitResult[1].p1, splitResult[1].p2)\n        );\n      }\n    }\n\n    // Convert front/back from single nodes to built trees\n    if (recursiveArray[0].front) {\n      recursiveArray[0].front = this.build(this.collectNodes(recursiveArray[0].front));\n    }\n    if (recursiveArray[0].back) {\n      recursiveArray[0].back = this.build(this.collectNodes(recursiveArray[0].back));\n    }\n\n    return recursiveArray[0];\n  }\n\n  private insertNode(existing: BSPNode | null, newNode: BSPNode): BSPNode {\n    if (!existing) {\n      return newNode;\n    }\n    // Chain nodes temporarily - they'll be rebuilt\n    newNode.front = existing;\n    return newNode;\n  }\n\n  private collectNodes(node: BSPNode | null): BSPNode[] {\n    if (!node) return [];\n    const nodes: BSPNode[] = [new BSPNode(node.id, node.p1, node.p2)];\n    if (node.front) nodes.push(...this.collectNodes(node.front));\n    if (node.back) nodes.push(...this.collectNodes(node.back));\n    return nodes;\n  }\n\n  private divide(w1: BSPNode, w2: BSPNode): number | [{ p1: Point; p2: Point }, { p1: Point; p2: Point }] {\n    const w2_n: [boolean, boolean] = [\n      inFrontOf(w2.p1, w1.p1, w1.p2),\n      inFrontOf(w2.p2, w1.p1, w1.p2)\n    ];\n\n    if (w2_n[0] && w2_n[1]) {\n      return 1; // Both line points are in front\n    }\n    if (!w2_n[0] && !w2_n[1]) {\n      return -1; // Both line points are behind\n    }\n\n    // We need to divide the lines\n    const p3 = lineIntersection(\n      w1.p1[0], w1.p1[1], w1.p2[0], w1.p2[1],\n      w2.p1[0], w2.p1[1], w2.p2[0], w2.p2[1]\n    );\n\n    if (!p3) {\n      return w2_n[0] ? 1 : -1;\n    }\n\n    const intersectionPoint: Point = [p3[0], p3[1]];\n\n    if (w2_n[0]) {\n      // First line point is in front and second behind\n      return [\n        { p1: w2.p1, p2: intersectionPoint },\n        { p1: intersectionPoint, p2: w2.p2 }\n      ];\n    } else {\n      // First line point is behind and second in front\n      return [\n        { p1: intersectionPoint, p2: w2.p2 },\n        { p1: w2.p1, p2: intersectionPoint }\n      ];\n    }\n  }\n}\n\n/** Beam tree for tracking virtual sources and reflection paths */\nclass BeamTree {\n  mainNode: BeamNode;\n\n  constructor(source: Source, walls: Wall[], maxOrder: number) {\n    this.mainNode = new BeamNode(-1, null, source.p0);\n\n    for (let i = 0; i < walls.length; i++) {\n      const vs = pointMirror(source.p0, walls[i].p1, walls[i].p2);\n      const beam = new Beam(vs, walls[i].p1, walls[i].p2);\n      const childNode = new BeamNode(i, this.mainNode, vs);\n      this.mainNode.children.push(childNode);\n\n      // Recursively build children\n      this.buildBeam(beam, childNode, walls, 0, maxOrder);\n    }\n  }\n\n  private buildBeam(beam: Beam, node: BeamNode, walls: Wall[], order: number, maxOrder: number): void {\n    if (order > maxOrder) return;\n\n    // Make sure the source is mathematically behind the wall\n    if (inFrontOf(beam.vs, beam.p1, beam.p2)) {\n      const temp = beam.p2;\n      beam.p2 = beam.p1;\n      beam.p1 = temp;\n    }\n\n    for (let i = 0; i < walls.length; i++) {\n      if (node.id === i) continue;\n\n      let newLine: { p1: Point; p2: Point } | undefined;\n\n      // Three segments A, B (inside) and C\n      const p1_b = !inFrontOf(walls[i].p1, beam.p1, beam.p2);\n      const p2_b = !inFrontOf(walls[i].p2, beam.p1, beam.p2);\n      if (p1_b && p2_b) continue;\n\n      const p1_a = !inFrontOf(walls[i].p1, beam.vs, beam.p2);\n      const p2_a = !inFrontOf(walls[i].p2, beam.vs, beam.p2);\n      if (p1_a && p2_a) continue;\n\n      const p1_c = inFrontOf(walls[i].p1, beam.vs, beam.p1);\n      const p2_c = inFrontOf(walls[i].p2, beam.vs, beam.p1);\n      if (p1_c && p2_c) continue;\n\n      const p1_in = !p1_a && !p1_b && !p1_c;\n      const p2_in = !p2_a && !p2_b && !p2_c;\n\n      let A = false;\n      let B = false;\n      let C = false;\n      let int: IntersectionResult = null;\n\n      if (p1_in && p2_in) {\n        newLine = { p1: walls[i].p1, p2: walls[i].p2 };\n      } else if (p1_in) {\n        newLine = { p1: walls[i].p1, p2: [0, 0] };\n        if (p2_a && !p2_b) {\n          A = true;\n        } else if (p2_a && p2_b && p2_c) {\n          A = true; B = true; C = true;\n        } else if (p2_a && p2_b) {\n          A = true; B = true;\n        } else if (!p2_a && p2_b && !p2_c) {\n          B = true;\n        } else if (p2_c && p2_b) {\n          B = true; C = true;\n        } else if (p2_c && !p2_b) {\n          C = true;\n        }\n      } else if (p2_in) {\n        newLine = { p1: walls[i].p2, p2: [0, 0] };\n        if (p1_a && !p1_b) {\n          A = true;\n        } else if (p1_a && p1_b && p1_c) {\n          A = true; B = true; C = true;\n        } else if (p1_a && p1_b) {\n          A = true; B = true;\n        } else if (!p1_a && p1_b && !p1_c) {\n          B = true;\n        } else if (p1_c && p1_b) {\n          B = true; C = true;\n        } else if (p1_c && !p1_b) {\n          C = true;\n        }\n      } else {\n        // All points are outside boundaries\n        if ((p1_a && p2_b) || (p2_a && p1_b)) {\n          const int_a = lineIntersection(\n            beam.p2[0], beam.p2[1],\n            beam.p2[0] + (beam.p2[0] - beam.vs[0]) * 2,\n            beam.p2[1] + (beam.p2[1] - beam.vs[1]) * 2,\n            walls[i].p1[0], walls[i].p1[1],\n            walls[i].p2[0], walls[i].p2[1]\n          );\n          if (int_a && int_a[4]) {\n            const int_b = lineIntersection(\n              beam.p1[0], beam.p1[1], beam.p2[0], beam.p2[1],\n              walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n            );\n            if (int_b) {\n              newLine = { p1: [int_a[0], int_a[1]], p2: [int_b[0], int_b[1]] };\n            }\n          }\n        } else if ((p1_b && p2_c) || (p2_b && p1_c)) {\n          const int_b = lineIntersection(\n            beam.p1[0], beam.p1[1], beam.p2[0], beam.p2[1],\n            walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n          );\n          if (int_b && int_b[4]) {\n            const int_c = lineIntersection(\n              beam.p1[0], beam.p1[1],\n              beam.p1[0] + (beam.p1[0] - beam.vs[0]) * 2,\n              beam.p1[1] + (beam.p1[1] - beam.vs[1]) * 2,\n              walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n            );\n            if (int_c) {\n              newLine = { p1: [int_b[0], int_b[1]], p2: [int_c[0], int_c[1]] };\n            }\n          }\n        } else if (((p1_a && p2_c) || (p2_a && p1_c)) && (!p1_b && !p2_b)) {\n          const int_a = lineIntersection(\n            beam.p2[0], beam.p2[1],\n            beam.p2[0] + (beam.p2[0] - beam.vs[0]) * 2,\n            beam.p2[1] + (beam.p2[1] - beam.vs[1]) * 2,\n            walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n          );\n          const int_c = lineIntersection(\n            beam.p1[0], beam.p1[1],\n            beam.p1[0] + (beam.p1[0] - beam.vs[0]) * 2,\n            beam.p1[1] + (beam.p1[1] - beam.vs[1]) * 2,\n            walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n          );\n          if (int_a && int_c) {\n            newLine = { p1: [int_a[0], int_a[1]], p2: [int_c[0], int_c[1]] };\n          }\n        }\n      }\n\n      // Calculate intersection based on flags\n      if (A && !B && !C) {\n        int = lineIntersection(\n          beam.vs[0], beam.vs[1], beam.p2[0], beam.p2[1],\n          walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n        );\n      } else if (A && B && C) {\n        int = lineIntersection(\n          beam.p2[0], beam.p2[1],\n          beam.p2[0] + (beam.p2[0] - beam.vs[0]),\n          beam.p2[1] + (beam.p2[1] - beam.vs[1]),\n          walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n        );\n        if (!int || !int[4]) {\n          int = lineIntersection(\n            beam.p1[0], beam.p1[1], beam.p2[0], beam.p2[1],\n            walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n          );\n        }\n        if (!int || !int[4]) {\n          int = lineIntersection(\n            beam.p1[0], beam.p1[1],\n            beam.p1[0] + (beam.p1[0] - beam.vs[0]) * 2,\n            beam.p1[1] + (beam.p1[1] - beam.vs[1]) * 2,\n            walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n          );\n        }\n      } else if (A && B) {\n        int = lineIntersection(\n          beam.p2[0], beam.p2[1],\n          beam.p2[0] + (beam.p2[0] - beam.vs[0]),\n          beam.p2[1] + (beam.p2[1] - beam.vs[1]),\n          walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n        );\n        if (!int || !int[4]) {\n          int = lineIntersection(\n            beam.p1[0], beam.p1[1], beam.p2[0], beam.p2[1],\n            walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n          );\n        }\n      } else if (!A && B && !C) {\n        int = lineIntersection(\n          beam.p1[0], beam.p1[1], beam.p2[0], beam.p2[1],\n          walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n        );\n      } else if (B && C) {\n        int = lineIntersection(\n          beam.p1[0], beam.p1[1], beam.p2[0], beam.p2[1],\n          walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n        );\n        if (!int || !int[4]) {\n          int = lineIntersection(\n            beam.p1[0], beam.p1[1],\n            beam.p1[0] + (beam.p1[0] - beam.vs[0]),\n            beam.p1[1] + (beam.p1[1] - beam.vs[1]),\n            walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n          );\n        }\n      } else if (!A && !B && C) {\n        int = lineIntersection(\n          beam.vs[0], beam.vs[1], beam.p1[0], beam.p1[1],\n          walls[i].p1[0], walls[i].p1[1], walls[i].p2[0], walls[i].p2[1]\n        );\n      }\n\n      if (int && newLine) {\n        newLine.p2 = [int[0], int[1]];\n      }\n\n      if (newLine) {\n        const newBeam = new Beam(\n          pointMirror(beam.vs, walls[i].p1, walls[i].p2),\n          newLine.p1,\n          newLine.p2\n        );\n        const childNode = new BeamNode(i, node, newBeam.vs);\n        node.children.push(childNode);\n        this.buildBeam(newBeam, childNode, walls, order + 1, maxOrder);\n      }\n    }\n  }\n}\n\n/* Helper functions */\n\n/** Returns the intersection point of two lines along with additional information */\nfunction lineIntersection(\n  x11: number, y11: number, x12: number, y12: number,\n  x21: number, y21: number, x22: number, y22: number\n): IntersectionResult {\n  const denominator = ((y22 - y21) * (x12 - x11)) - ((x22 - x21) * (y12 - y11));\n  if (denominator === 0) {\n    return null;\n  }\n\n  const a_temp = y11 - y21;\n  const b_temp = x11 - x21;\n  const numerator1 = ((x22 - x21) * a_temp) - ((y22 - y21) * b_temp);\n  const numerator2 = ((x12 - x11) * a_temp) - ((y12 - y11) * b_temp);\n  const a = numerator1 / denominator;\n  const b = numerator2 / denominator;\n\n  const x = x11 + (a * (x12 - x11));\n  const y = y11 + (a * (y12 - y11));\n\n  const onRay1 = a > 0;\n  const onLine1 = a > 0 && a < 1;\n  const onRay2 = b > 0;\n  const onLine2 = b > 0 && b < 1;\n\n  return [x, y, onLine1, onLine2, onRay1, onRay2];\n}\n\n/** Returns true if p0 is in front of line defined by p1, p2 */\nfunction inFrontOf(p0: Point, p1: Point, p2: Point): boolean {\n  // Line normal\n  const n1: Point = [-(p2[1] - p1[1]), (p2[0] - p1[0])];\n  // Dot product for distance after translating so dist is relative to origin\n  return n1[0] * (p0[0] - p1[0]) + n1[1] * (p0[1] - p1[1]) > 0;\n}\n\n/** Mirrors point p0 along line defined by p1 and p2 */\nfunction pointMirror(p0: Point, p1: Point, p2: Point): Point {\n  // Line normal\n  let n1: Point = [-(p2[1] - p1[1]), (p2[0] - p1[0])];\n  const n1_len = Math.sqrt(n1[0] * n1[0] + n1[1] * n1[1]);\n  if (n1_len === 0) {\n    return p0; // Degenerate wall (p1 === p2), return original point\n  }\n  n1 = [n1[0] / n1_len, n1[1] / n1_len];\n  // Dot product for distance after translating so dist is relative to origin\n  const dist = 2 * (n1[0] * (p0[0] - p1[0]) + n1[1] * (p0[1] - p1[1]));\n  // New point is negative normal x distance added to original position\n  return [p0[0] - n1[0] * dist, p0[1] - n1[1] * dist];\n}\n\n/** Main solver for beam tracing */\nexport class Solver {\n  private readonly maxOrder: number;\n  private readonly walls: Wall[];\n  private readonly source: Source;\n  private readonly bsp: BSPTree;\n  private readonly beams: BeamTree;\n\n  /**\n   * @param walls Array of Wall objects defining the environment\n   * @param source The sound source position\n   * @param reflectionOrder Maximum number of reflections to compute (default: 5)\n   *\n   * Note: In v1.x, this parameter was incorrectly offset by -2 internally,\n   * so reflectionOrder=4 actually computed 3 reflections. As of v2.0,\n   * reflectionOrder now correctly represents the number of reflections.\n   * If migrating from v1.x, subtract 1 from your previous value.\n   */\n  constructor(walls: Wall[], source: Source, reflectionOrder?: number) {\n    if (!walls || walls.length === 0) {\n      throw new Error('BeamTrace2D: at least one wall is required');\n    }\n    if (!source) {\n      throw new Error('BeamTrace2D: source is required');\n    }\n    // maxOrder is the 0-based tree depth limit; reflectionOrder N means N reflections (0 to N-1)\n    this.maxOrder = reflectionOrder !== undefined ? reflectionOrder - 1 : 4;\n    this.walls = walls;\n    this.source = source;\n    this.bsp = new BSPTree(walls);\n    this.beams = new BeamTree(source, walls, this.maxOrder);\n  }\n\n  /** Get all valid reflection paths from source to listener */\n  getPaths(listener: Listener): ReflectionPath[] {\n    if (!listener) {\n      throw new Error(\"BeamTrace2D: listener is required\");\n    }\n    return this.findPaths(listener, this.beams.mainNode);\n  }\n\n  /** Recursive function for going through all beams */\n  private findPaths(listener: Listener, node: BeamNode): ReflectionPath[] {\n    let pathArray: ReflectionPath[] = [];\n\n    for (let i = 0; i < node.children.length; i++) {\n      pathArray = pathArray.concat(this.findPaths(listener, node.children[i]));\n    }\n\n    const pTree = this.traverseBeam(listener.p0, node, null, [[listener.p0[0], listener.p0[1], null]]);\n    if (pTree) {\n      pathArray.push(pTree);\n    }\n\n    return pathArray;\n  }\n\n  /** Traverse the beam at the given node recursively while testing for intersections */\n  private traverseBeam(\n    p0: Point,\n    node: BeamNode,\n    prevNode: BeamNode | null,\n    pTree: ReflectionPath\n  ): ReflectionPath | null {\n    const ignoreId = prevNode ? prevNode.id : -1;\n\n    // Find intersection from location to next image source\n    let int = this.rayTrace(p0, node.vs, this.bsp.mainNode, ignoreId, node.id, 0);\n\n    if (!int || (node.id !== -1 && int[6] !== node.id) || !int[2] || !int[3]) {\n      int = null;\n    }\n\n    if (node.id === -1) {\n      // The path to the source\n      if (!int) {\n        pTree.push([node.vs[0], node.vs[1], null]);\n        return pTree;\n      } else {\n        return null; // The path to the source is blocked\n      }\n    } else {\n      if (!int) return null;\n\n      pTree.push([int[0], int[1], node.id]);\n      return this.traverseBeam([int[0], int[1]], node.parent!, node, pTree);\n    }\n  }\n\n  /** Check intersection with current BSP node */\n  private checkNodeIntersection(\n    p1: Point,\n    p2: Point,\n    bspNode: BSPNode,\n    ignoreId: number\n  ): IntersectionResult {\n    const lineInt = lineIntersection(\n      p1[0], p1[1], p2[0], p2[1],\n      bspNode.p1[0], bspNode.p1[1], bspNode.p2[0], bspNode.p2[1]\n    );\n    if (bspNode.id === ignoreId) {\n      return null;\n    } else if (lineInt) {\n      return [lineInt[0], lineInt[1], lineInt[2], lineInt[3], lineInt[4], lineInt[5], bspNode.id];\n    }\n    return null;\n  }\n\n  /** Ray tracing using BSP tree */\n  private rayTrace(\n    p1: Point,\n    p2: Point,\n    bspNode: BSPNode | null,\n    ignoreId: number,\n    validId: number,\n    order: number\n  ): IntersectionResult {\n    if (!bspNode) return null;\n\n    let int: IntersectionResult = null;\n    const isFront = inFrontOf(p1, bspNode.p1, bspNode.p2);\n    const nearChild = isFront ? bspNode.front : bspNode.back;\n    const farChild = isFront ? bspNode.back : bspNode.front;\n\n    int = this.rayTrace(p1, p2, nearChild, ignoreId, validId, order);\n\n    if (!int || !int[2] || !int[3]) {\n      int = this.checkNodeIntersection(p1, p2, bspNode, ignoreId);\n    }\n\n    if (!int || !int[2] || !int[3]) {\n      int = this.rayTrace(p1, p2, farChild, ignoreId, validId, order);\n    }\n\n    return int;\n  }\n}\n\n// Re-export optimization module\nexport {\n  OptimizedSolver,\n  type Line2D,\n  type FailLineType,\n  type SkipCircle,\n  type Bucket,\n  type PerformanceMetrics\n} from './optimization';\n\n// Re-export geometry utilities for advanced usage\nexport * as geometry from './geometry';\n\n// Default export for convenience\nconst BeamTrace2D = {\n  Wall,\n  Source,\n  Listener,\n  Solver\n};\n\nexport default BeamTrace2D;\n", "// Script for demonstrating BeamTrace2D\n\nimport { Wall, Source, Listener, Solver, Point, ReflectionPath } from './beamtrace2d';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  // Basic drawing stuff\n  const canvas = document.getElementById('beamCanvas') as HTMLCanvasElement;\n  if (!canvas) {\n    console.log('Error: canvas element not found');\n    return;\n  }\n\n  const ctx = canvas.getContext('2d');\n  if (!ctx) {\n    console.log('Error: canvas not supported');\n    return;\n  }\n\n  // First init the walls\n  const walls: Wall[] = [\n    new Wall([100, 130], [120, 220]), // Wall id 0\n    new Wall([50, 55], [220, 60]),    // Wall id 1\n    new Wall([220, 60], [250, 220]),  // Wall id 2...\n    new Wall([50, 220], [200, 220]),  // etc\n    new Wall([50, 220], [50, 55]),\n    new Wall([200, 220], [40, 230]),\n    new Wall([40, 230], [30, 290]),\n    new Wall([30, 290], [60, 270]),\n    new Wall([60, 270], [290, 270]),\n    new Wall([290, 270], [250, 220]),\n  ];\n\n  // Then a listener and a source\n  const listener = new Listener([80, 100]);\n  const source = new Source([200, 80]);\n\n  // Pass the walls and the source to the solver, which does pre-calculations for fast solving\n  const reflectionOrder = 4; // How many reflections do we want to calculate?\n  let solver = new Solver(walls, source, reflectionOrder); // Init the solver\n\n  // path_array will contain the reflection paths\n  let pathArray: ReflectionPath[] = solver.getPaths(listener);\n\n  // A function for painting the solution\n  function redraw(): void {\n    ctx!.clearRect(0, 0, 300, 300);\n    ctx!.lineWidth = 2.0;\n    walls.forEach((wall) => {\n      wall.draw(ctx!);\n    });\n    ctx!.lineWidth = 1.0;\n    listener.draw(ctx!);\n    source.draw(ctx!);\n\n    // Draw the paths\n    if (pathArray) {\n      for (let i = 0; i < pathArray.length; i++) {\n        // Draw each path\n        let first = true;\n        ctx!.strokeStyle = 'rgba(0,0,255,0.2)';\n        ctx!.beginPath();\n        ctx!.lineWidth = 2;\n        pathArray[i].forEach((p) => {\n          if (first) {\n            ctx!.moveTo(p[0], p[1]);\n            first = false;\n          } else {\n            ctx!.lineTo(p[0], p[1]);\n          }\n        });\n        ctx!.stroke();\n        ctx!.strokeStyle = 'black';\n        ctx!.lineWidth = 1;\n      }\n    }\n  }\n\n  // Get canvas position for mouse coordinates\n  function getMousePos(e: MouseEvent): Point {\n    const rect = canvas!.getBoundingClientRect();\n    return [e.clientX - rect.left, e.clientY - rect.top];\n  }\n\n  // If the walls or source position are updated, the solver needs to be initialized again\n  canvas.addEventListener('click', (e: MouseEvent) => {\n    source.p0 = getMousePos(e); // Change the source position\n    solver = new Solver(walls, source, reflectionOrder); // Init the solver with the new source position\n    pathArray = solver.getPaths(listener); // Update reflection paths\n    redraw();\n  });\n\n  // Update the listener position\n  canvas.addEventListener('mousemove', (e: MouseEvent) => {\n    listener.p0 = getMousePos(e); // Change the listener position\n    pathArray = solver.getPaths(listener); // Update reflection paths\n    redraw();\n  });\n\n  redraw(); // First redraw\n});\n"],
  "mappings": "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",
  "names": []
}
