{
  "version": 3,
  "sources": ["../src/main3d.ts", "../src/core/vector3.ts", "../src/core/plane3d.ts", "../src/geometry/polygon3d.ts", "../src/geometry/polygon-split.ts", "../src/geometry/clipping3d.ts", "../src/structures/bsp3d.ts", "../src/structures/beam3d.ts", "../src/structures/beamtree3d.ts", "../src/optimization/failplane3d.ts", "../src/optimization/skipsphere3d.ts", "../src/solver/solver3d.ts", "../src/beamtrace3d.ts"],
  "sourcesContent": ["/**\n * BeamTrace3D Interactive Demo\n *\n * Three.js visualization of 3D acoustic beam tracing.\n * Click on the floor to move the listener and see reflection paths update in real-time.\n */\n\nimport * as THREE from 'three';\n// @ts-expect-error - OrbitControls loaded from CDN via import map\nimport { OrbitControls } from 'three/addons/controls/OrbitControls.js';\nimport {\n  createShoeboxRoom,\n  Source3D,\n  Listener3D,\n  Solver3D,\n  getPathReflectionOrder,\n  Polygon3D\n} from './beamtrace3d';\nimport type { Vector3 as BT_Vector3, ReflectionPath3D, BeamVisualizationData } from './beamtrace3d';\n\n// ============================================================================\n// Concord Room Geometry (L-shaped room from CRAM)\n// ============================================================================\n\n/**\n * Create the Concord room geometry - an L-shaped room with 9 surfaces.\n * Dimensions approximately: 12.43m x 10.86m x 4.88m (with L-shape cutout)\n *\n * Surface names: right1, back1, right2, back2, left, front, slope, ceil, floor\n */\nfunction createConcordRoom(): Polygon3D[] {\n  const polygons: Polygon3D[] = [];\n\n  // Surface data extracted from concord.json\n  // Each surface has triangles - we convert them to Polygon3D format\n  // Format: [x, y, z] triplets, every 3 vertices = 1 triangle\n\n  const surfaces: { name: string; vertices: number[] }[] = [\n    {\n      // right1 - right wall (lower section)\n      name: 'right1',\n      vertices: [\n        12.430130004882812, 2.3483328819274902, 4.876800060272217,\n        12.430130004882812, 5.575300216674805, 4.876800060272217,\n        12.430130004882812, 5.575300216674805, 0,\n        12.430130004882812, 5.575300216674805, 0,\n        12.430130004882812, 0, 0,\n        12.430130004882812, 0, 2.9337000846862793,\n        12.430130004882812, 0, 2.9337000846862793,\n        12.430130004882812, 2.3483328819274902, 4.876800060272217,\n        12.430130004882812, 5.575300216674805, 0\n      ]\n    },\n    {\n      // back1 - back wall (lower section)\n      name: 'back1',\n      vertices: [\n        6.215065002441406, 5.575300216674805, 4.876800060272217,\n        12.430130004882812, 5.575300216674805, 0,\n        12.430130004882812, 5.575300216674805, 4.876800060272217,\n        6.215065002441406, 5.575300216674805, 4.876800060272217,\n        6.215065002441406, 5.575300216674805, 0,\n        12.430130004882812, 5.575300216674805, 0\n      ]\n    },\n    {\n      // right2 - right wall (upper section of L)\n      name: 'right2',\n      vertices: [\n        6.215065002441406, 10.855531692504883, 0,\n        6.215065002441406, 5.575300216674805, 4.876800060272217,\n        6.215065002441406, 10.855531692504883, 4.876800060272217,\n        6.215065002441406, 10.855531692504883, 0,\n        6.215065002441406, 5.575300216674805, 0,\n        6.215065002441406, 5.575300216674805, 4.876800060272217\n      ]\n    },\n    {\n      // back2 - back wall (upper section)\n      name: 'back2',\n      vertices: [\n        0, 10.855531692504883, 0,\n        6.215065002441406, 10.855531692504883, 4.876800060272217,\n        0, 10.855531692504883, 4.876800060272217,\n        0, 10.855531692504883, 0,\n        6.215065002441406, 10.855531692504883, 0,\n        6.215065002441406, 10.855531692504883, 4.876800060272217\n      ]\n    },\n    {\n      // left - left wall\n      name: 'left',\n      vertices: [\n        0, 2.3483328819274902, 4.876800060272217,\n        0, 0, 0,\n        0, 10.855531692504883, 0,\n        0, 10.855531692504883, 0,\n        0, 10.855531692504883, 4.876800060272217,\n        0, 2.3483328819274902, 4.876800060272217,\n        0, 2.3483328819274902, 4.876800060272217,\n        0, 0, 2.9337000846862793,\n        0, 0, 0\n      ]\n    },\n    {\n      // front - front wall\n      name: 'front',\n      vertices: [\n        12.430130004882812, 0, 0,\n        0, 0, 2.9337000846862793,\n        12.430130004882812, 0, 2.9337000846862793,\n        12.430130004882812, 0, 0,\n        0, 0, 0,\n        0, 0, 2.9337000846862793\n      ]\n    },\n    {\n      // slope - sloped ceiling section at front\n      name: 'slope',\n      vertices: [\n        12.430130004882812, 0, 2.9337000846862793,\n        0, 2.3483328819274902, 4.876800060272217,\n        12.430130004882812, 2.3483328819274902, 4.876800060272217,\n        12.430130004882812, 0, 2.9337000846862793,\n        0, 0, 2.9337000846862793,\n        0, 2.3483328819274902, 4.876800060272217\n      ]\n    },\n    {\n      // ceil - ceiling (L-shaped)\n      name: 'ceil',\n      vertices: [\n        12.430130004882812, 2.3483328819274902, 4.876800060272217,\n        6.215065002441406, 5.575300216674805, 4.876800060272217,\n        12.430130004882812, 5.575300216674805, 4.876800060272217,\n        6.215065002441406, 5.575300216674805, 4.876800060272217,\n        0, 10.855531692504883, 4.876800060272217,\n        6.215065002441406, 10.855531692504883, 4.876800060272217,\n        12.430130004882812, 2.3483328819274902, 4.876800060272217,\n        0, 2.3483328819274902, 4.876800060272217,\n        6.215065002441406, 5.575300216674805, 4.876800060272217,\n        6.215065002441406, 5.575300216674805, 4.876800060272217,\n        0, 2.3483328819274902, 4.876800060272217,\n        0, 10.855531692504883, 4.876800060272217\n      ]\n    },\n    {\n      // floor - floor (L-shaped)\n      name: 'floor',\n      vertices: [\n        6.215065002441406, 5.575300216674805, 0,\n        12.430130004882812, 0, 0,\n        12.430130004882812, 5.575300216674805, 0,\n        6.215065002441406, 5.575300216674805, 0,\n        0, 10.855531692504883, 0,\n        0, 0, 0,\n        6.215065002441406, 5.575300216674805, 0,\n        0, 0, 0,\n        12.430130004882812, 0, 0,\n        6.215065002441406, 5.575300216674805, 0,\n        6.215065002441406, 10.855531692504883, 0,\n        0, 10.855531692504883, 0\n      ]\n    }\n  ];\n\n  // Convert each surface's triangles to Polygon3D format\n  for (const surface of surfaces) {\n    const verts = surface.vertices;\n    // Each triangle is 9 values (3 vertices * 3 components)\n    for (let i = 0; i < verts.length; i += 9) {\n      const triangleVerts: BT_Vector3[] = [\n        [verts[i], verts[i + 1], verts[i + 2]],\n        [verts[i + 3], verts[i + 4], verts[i + 5]],\n        [verts[i + 6], verts[i + 7], verts[i + 8]]\n      ];\n      polygons.push(Polygon3D.create(triangleVerts));\n    }\n  }\n\n  return polygons;\n}\n\n// ============================================================================\n// Auditorium Room Geometry (from CRAM auditorium.json)\n// ============================================================================\n\n/**\n * Create the Auditorium room geometry - a fan-shaped room with sloped floor.\n * Dimensions approximately: 26m x 23m x 9m\n */\nfunction createAuditoriumRoom(): Polygon3D[] {\n  const polygons: Polygon3D[] = [];\n\n  // Surface data extracted from auditorium.json\n  // Each surface has triangles - we convert them to Polygon3D format\n  // Format: [x, y, z] triplets, every 3 vertices = 1 triangle\n\n  const surfaces: { name: string; vertices: number[] }[] = [\n    {\n      name: \"stage-side\",\n      vertices: [\n        3.6396543979644775, 14.278063774108887, -0.6776000261306763, 3.6396543979644775, 14.278063774108887, 0, 3.6396543979644775, -0.7260642051696777, -0.6776000261306763,\n        3.6396543979644775, -0.7260642051696777, 0, 3.6396543979644775, -0.7260642051696777, -0.6776000261306763, 3.6396543979644775, 14.278063774108887, 0\n      ]\n    },\n    {\n      name: \"stage-floor\",\n      vertices: [\n        3.6396543979644775, -0.7260642051696777, 0, 3.6396543979644775, 14.278063774108887, 0, 3.388000011444092, -1.3552000522613525, 0,\n        3.6396543979644775, 14.278063774108887, 0, 3.388000011444092, 14.90719985961914, 0, 3.388000011444092, -1.3552000522613525, 0,\n        3.388000011444092, -1.3552000522613525, 0, 3.388000011444092, 14.90719985961914, 0, 0, 0, 0,\n        0, 13.552000045776367, 0, 0, 0, 0, 3.388000011444092, 14.90719985961914, 0\n      ]\n    },\n    {\n      name: \"right-wall-1\",\n      vertices: [\n        25.27349090576172, 0, 8.243200302124023, 25.27349090576172, 0, 0.5723999738693237, 23.240692138671875, -4.500878810882568, 8.243200302124023,\n        23.240692138671875, -4.500878810882568, 0.5723999738693237, 23.240692138671875, -4.500878810882568, 8.243200302124023, 25.27349090576172, 0, 0.5723999738693237\n      ]\n    },\n    {\n      name: \"right-wall-2\",\n      vertices: [\n        25.27349090576172, 13.552000045776367, 8.243200302124023, 25.27349090576172, 13.552000045776367, 0.5723999738693237, 25.951091766357422, 6.776000022888184, 8.243200302124023,\n        25.951091766357422, 6.776000022888184, 0.5723999738693237, 25.951091766357422, 6.776000022888184, 8.243200302124023, 25.27349090576172, 13.552000045776367, 0.5723999738693237\n      ]\n    },\n    {\n      name: \"right-wall-3\",\n      vertices: [\n        25.951091766357422, 6.776000022888184, 8.243200302124023, 25.951091766357422, 6.776000022888184, 0.5723999738693237, 25.27349090576172, 0, 8.243200302124023,\n        25.27349090576172, 0, 0.5723999738693237, 25.27349090576172, 0, 8.243200302124023, 25.951091766357422, 6.776000022888184, 0.5723999738693237\n      ]\n    },\n    {\n      name: \"left-wall-1\",\n      vertices: [\n        23.240692138671875, 18.052879333496094, 8.243200302124023, 23.240692138671875, 18.052879333496094, 0.5723999738693237, 25.27349090576172, 13.552000045776367, 8.243200302124023,\n        25.27349090576172, 13.552000045776367, 0.5723999738693237, 25.27349090576172, 13.552000045776367, 8.243200302124023, 23.240692138671875, 18.052879333496094, 0.5723999738693237\n      ]\n    },\n    {\n      name: \"audience-floor-1\",\n      vertices: [\n        25.951091766357422, 6.776000022888184, 0.5723999738693237, 25.27349090576172, 13.552000045776367, 0.5723999738693237, 25.27349090576172, 0, 0.5723999738693237,\n        25.27349090576172, 13.552000045776367, 0.5723999738693237, 23.240692138671875, 18.052879333496094, 0.5723999738693237, 25.27349090576172, 0, 0.5723999738693237,\n        23.240692138671875, -4.500878810882568, 0.5723999738693237, 25.27349090576172, 0, 0.5723999738693237, 23.240692138671875, 18.052879333496094, 0.5723999738693237\n      ]\n    },\n    {\n      name: \"audience-floor-2\",\n      vertices: [\n        13.076691627502441, -4.500878810882568, 0.07240000367164612, 13.076691627502441, 18.052879333496094, 0.07240000367164612, 3.6396543979644775, -0.7260642051696777, -0.6776000261306763,\n        3.6396543979644775, 14.278063774108887, -0.6776000261306763, 3.6396543979644775, -0.7260642051696777, -0.6776000261306763, 13.076691627502441, 18.052879333496094, 0.07240000367164612\n      ]\n    },\n    {\n      name: \"audience-floor-3\",\n      vertices: [\n        23.240692138671875, -4.500878810882568, 0.5723999738693237, 23.240692138671875, 18.052879333496094, 0.5723999738693237, 13.076691627502441, -4.500878810882568, 0.07240000367164612,\n        13.076691627502441, 18.052879333496094, 0.07240000367164612, 13.076691627502441, -4.500878810882568, 0.07240000367164612, 23.240692138671875, 18.052879333496094, 0.5723999738693237\n      ]\n    },\n    {\n      name: \"front-wall-1\",\n      vertices: [\n        13.076691627502441, -4.500878810882568, 7.493199825286865, 13.076691627502441, -4.500878810882568, 0.07240000367164612, 3.6396543979644775, -0.7260642051696777, 4.743199825286865,\n        3.6396543979644775, -0.7260642051696777, 4.743199825286865, 13.076691627502441, -4.500878810882568, 0.07240000367164612, 3.6396543979644775, -0.7260642051696777, 0,\n        3.6396543979644775, -0.7260642051696777, -0.6776000261306763, 3.6396543979644775, -0.7260642051696777, 0, 13.076691627502441, -4.500878810882568, 0.07240000367164612\n      ]\n    },\n    {\n      name: \"back-wall-1\",\n      vertices: [\n        15.076691627502441, 18.052879333496094, 8.243200302124023, 13.076691627502441, 18.052879333496094, 7.493199825286865, 23.240692138671875, 18.052879333496094, 8.243200302124023,\n        23.240692138671875, 18.052879333496094, 8.243200302124023, 13.076691627502441, 18.052879333496094, 7.493199825286865, 23.240692138671875, 18.052879333496094, 0.5723999738693237,\n        13.076691627502441, 18.052879333496094, 0.07240000367164612, 23.240692138671875, 18.052879333496094, 0.5723999738693237, 13.076691627502441, 18.052879333496094, 7.493199825286865\n      ]\n    },\n    {\n      name: \"back-wall-2\",\n      vertices: [\n        13.076691627502441, 18.052879333496094, 7.493199825286865, 3.6396543979644775, 14.278063774108887, 4.743199825286865, 13.076691627502441, 18.052879333496094, 0.07240000367164612,\n        3.6396543979644775, 14.278063774108887, 4.743199825286865, 3.6396543979644775, 14.278063774108887, 0, 13.076691627502441, 18.052879333496094, 0.07240000367164612,\n        3.6396543979644775, 14.278063774108887, -0.6776000261306763, 13.076691627502441, 18.052879333496094, 0.07240000367164612, 3.6396543979644775, 14.278063774108887, 0\n      ]\n    },\n    {\n      name: \"front-wall-2\",\n      vertices: [\n        15.076691627502441, -4.500878810882568, 8.243200302124023, 23.240692138671875, -4.500878810882568, 8.243200302124023, 13.076691627502441, -4.500878810882568, 7.493199825286865,\n        23.240692138671875, -4.500878810882568, 8.243200302124023, 23.240692138671875, -4.500878810882568, 0.5723999738693237, 13.076691627502441, -4.500878810882568, 7.493199825286865,\n        13.076691627502441, -4.500878810882568, 0.07240000367164612, 13.076691627502441, -4.500878810882568, 7.493199825286865, 23.240692138671875, -4.500878810882568, 0.5723999738693237\n      ]\n    },\n    {\n      name: \"ceiling\",\n      vertices: [\n        25.951091766357422, 6.776000022888184, 8.243200302124023, 25.27349090576172, 0, 8.243200302124023, 25.27349090576172, 13.552000045776367, 8.243200302124023,\n        25.27349090576172, 13.552000045776367, 8.243200302124023, 25.27349090576172, 0, 8.243200302124023, 23.240692138671875, 18.052879333496094, 8.243200302124023,\n        25.27349090576172, 0, 8.243200302124023, 23.240692138671875, -4.500878810882568, 8.243200302124023, 23.240692138671875, 18.052879333496094, 8.243200302124023,\n        23.240692138671875, 18.052879333496094, 8.243200302124023, 23.240692138671875, -4.500878810882568, 8.243200302124023, 15.076691627502441, 18.052879333496094, 8.243200302124023,\n        15.076691627502441, -4.500878810882568, 8.243200302124023, 15.076691627502441, 18.052879333496094, 8.243200302124023, 23.240692138671875, -4.500878810882568, 8.243200302124023\n      ]\n    },\n    {\n      name: \"stage-back-1\",\n      vertices: [\n        0, 0, 4.743199825286865, 3.388000011444092, -1.3552000522613525, 4.743199825286865, 0, 0, 0,\n        3.388000011444092, -1.3552000522613525, 0, 0, 0, 0, 3.388000011444092, -1.3552000522613525, 4.743199825286865\n      ]\n    },\n    {\n      name: \"stage-back-2\",\n      vertices: [\n        3.388000011444092, 14.90719985961914, 4.743199825286865, 0, 13.552000045776367, 4.743199825286865, 3.388000011444092, 14.90719985961914, 0,\n        0, 13.552000045776367, 0, 3.388000011444092, 14.90719985961914, 0, 0, 13.552000045776367, 4.743199825286865\n      ]\n    },\n    {\n      name: \"stage-side-1\",\n      vertices: [\n        3.6396543979644775, -0.7260642051696777, 4.743199825286865, 3.6396543979644775, -0.7260642051696777, 0, 3.388000011444092, -1.3552000522613525, 4.743199825286865,\n        3.388000011444092, -1.3552000522613525, 0, 3.388000011444092, -1.3552000522613525, 4.743199825286865, 3.6396543979644775, -0.7260642051696777, 0\n      ]\n    },\n    {\n      name: \"stage-side-2\",\n      vertices: [\n        3.388000011444092, 14.90719985961914, 4.743199825286865, 3.388000011444092, 14.90719985961914, 0, 3.6396543979644775, 14.278063774108887, 4.743199825286865,\n        3.6396543979644775, 14.278063774108887, 0, 3.6396543979644775, 14.278063774108887, 4.743199825286865, 3.388000011444092, 14.90719985961914, 0\n      ]\n    },\n    {\n      name: \"back-wall\",\n      vertices: [\n        0, 13.552000045776367, 0, 0, 13.552000045776367, 4.743199825286865, 0, 0, 0,\n        0, 0, 4.743199825286865, 0, 0, 0, 0, 13.552000045776367, 4.743199825286865\n      ]\n    },\n    {\n      name: \"stage-ceiling\",\n      vertices: [\n        3.6396543979644775, 14.278063774108887, 4.743199825286865, 3.6396543979644775, -0.7260642051696777, 4.743199825286865, 3.388000011444092, 14.90719985961914, 4.743199825286865,\n        3.6396543979644775, -0.7260642051696777, 4.743199825286865, 3.388000011444092, -1.3552000522613525, 4.743199825286865, 3.388000011444092, 14.90719985961914, 4.743199825286865,\n        3.388000011444092, 14.90719985961914, 4.743199825286865, 3.388000011444092, -1.3552000522613525, 4.743199825286865, 0, 13.552000045776367, 4.743199825286865,\n        0, 0, 4.743199825286865, 0, 13.552000045776367, 4.743199825286865, 3.388000011444092, -1.3552000522613525, 4.743199825286865\n      ]\n    },\n    {\n      name: \"ceiling-slope\",\n      vertices: [\n        15.076691627502441, 18.052879333496094, 8.243200302124023, 15.076691627502441, -4.500878810882568, 8.243200302124023, 13.076691627502441, 18.052879333496094, 7.493199825286865,\n        13.076691627502441, -4.500878810882568, 7.493199825286865, 13.076691627502441, 18.052879333496094, 7.493199825286865, 15.076691627502441, -4.500878810882568, 8.243200302124023\n      ]\n    },\n    {\n      name: \"ceiling-slope-2\",\n      vertices: [\n        13.076691627502441, 18.052879333496094, 7.493199825286865, 13.076691627502441, -4.500878810882568, 7.493199825286865, 3.6396543979644775, 14.278063774108887, 4.743199825286865,\n        3.6396543979644775, -0.7260642051696777, 4.743199825286865, 3.6396543979644775, 14.278063774108887, 4.743199825286865, 13.076691627502441, -4.500878810882568, 7.493199825286865\n      ]\n    }\n  ];\n\n  // Convert each surface's triangles to Polygon3D format\n  for (const surface of surfaces) {\n    const verts = surface.vertices;\n    // Each triangle is 9 values (3 vertices * 3 components)\n    for (let i = 0; i < verts.length; i += 9) {\n      const triangleVerts: BT_Vector3[] = [\n        [verts[i], verts[i + 1], verts[i + 2]],\n        [verts[i + 3], verts[i + 4], verts[i + 5]],\n        [verts[i + 6], verts[i + 7], verts[i + 8]]\n      ];\n      polygons.push(Polygon3D.create(triangleVerts));\n    }\n  }\n\n  return polygons;\n}\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\n// Room type selection\ntype RoomType = 'concord' | 'shoebox' | 'auditorium';\nlet currentRoomType: RoomType = 'concord';\n\n// Room dimensions - will be set based on room type\nlet ROOM_WIDTH = 12.43;   // X dimension (meters)\nlet ROOM_DEPTH = 10.86;   // Y dimension (meters)\nlet ROOM_HEIGHT = 4.88;   // Z dimension (meters)\n\n// Shoebox room default dimensions\nconst SHOEBOX_WIDTH = 10;\nconst SHOEBOX_DEPTH = 8;\nconst SHOEBOX_HEIGHT = 3;\nconst MIN_REFLECTION_ORDER = 0;\nconst MAX_REFLECTION_ORDER = 6;\nlet currentReflectionOrder = 3;\n\n// Visualization mode: 'paths' (rays) or 'beams' (cones)\nlet visualizationMode: 'paths' | 'beams' = 'paths';\n\n// Colors for different reflection orders\nconst PATH_COLORS = [\n  0x00ff00, // Direct (green)\n  0xffff00, // 1st order (yellow)\n  0xff8800, // 2nd order (orange)\n  0xff0088, // 3rd order (pink)\n  0x8800ff, // 4th+ order (purple)\n];\n\n// ============================================================================\n// Three.js Setup\n// ============================================================================\n\nconst scene = new THREE.Scene();\nscene.background = new THREE.Color(0x1a1a2e);\n\nconst camera = new THREE.PerspectiveCamera(\n  60,\n  window.innerWidth / window.innerHeight,\n  0.1,\n  1000\n);\n\nconst renderer = new THREE.WebGLRenderer({ antialias: true });\nrenderer.setSize(window.innerWidth, window.innerHeight);\nrenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\ndocument.body.appendChild(renderer.domElement);\n\n// Camera controls\nconst controls = new OrbitControls(camera, renderer.domElement);\ncontrols.enableDamping = true;\ncontrols.dampingFactor = 0.05;\ncontrols.minDistance = 5;\ncontrols.maxDistance = 50;\ncontrols.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent going below floor\n\n// ============================================================================\n// Lighting\n// ============================================================================\n\nconst ambientLight = new THREE.AmbientLight(0xffffff, 0.4);\nscene.add(ambientLight);\n\nconst directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\ndirectionalLight.position.set(10, 15, 10);\nscene.add(directionalLight);\n\n// ============================================================================\n// BeamTrace3D Setup\n// ============================================================================\n\n// Create room geometry\nlet roomPolygons = createConcordRoom();\n\n// Source position - from Concord save file: [3.7, 9.9, 1]\nlet sourcePos: BT_Vector3 = [3.7, 9.9, 1.0];\nlet source = new Source3D(sourcePos);\n\n// Timing metrics (smoothed with exponential moving average)\nlet lastPrecomputeTime = 0;\nlet smoothedComputeTime = 0;\nlet smoothedRenderTime = 0;\nconst TIMING_SMOOTHING = 0.3; // Lower = smoother, higher = more responsive\n\n// Create solver (will be recreated when reflection order changes)\nfunction createSolver(): InstanceType<typeof Solver3D> {\n  const start = performance.now();\n  const newSolver = new Solver3D(roomPolygons, source, {\n    maxReflectionOrder: currentReflectionOrder,\n    bucketSize: 16\n  });\n  lastPrecomputeTime = performance.now() - start;\n  return newSolver;\n}\n\nlet solver = createSolver();\n\nfunction recreateSolver(): void {\n  solver = createSolver();\n}\n\n// Listener position - from Concord save file: [10.8, 3.8, 1.2]\nlet listenerPos: BT_Vector3 = [10.8, 3.8, 1.2];\nconst listener = new Listener3D(listenerPos);\n\n// ============================================================================\n// Room Visualization\n// ============================================================================\n\n/**\n * Convert BeamTrace3D coordinates to Three.js coordinates\n * BeamTrace: X=width, Y=depth, Z=height (up)\n * Three.js:  X=width, Y=height (up), Z=depth\n */\nfunction btToThree(pos: BT_Vector3): THREE.Vector3 {\n  return new THREE.Vector3(pos[0], pos[2], pos[1]);\n}\n\n// Room wireframe\nconst roomGroup = new THREE.Group();\n\n// Floor mesh reference (will be recreated on room change)\nlet floor: THREE.Mesh;\nconst floorMaterial = new THREE.MeshStandardMaterial({\n  color: 0x444455,\n  roughness: 0.8,\n  metalness: 0.2,\n  side: THREE.DoubleSide\n});\n\n/**\n * Build the room visualization for Concord (L-shaped) room\n */\nfunction buildConcordRoomVisuals(): void {\n  // L-shaped floor for Concord room\n  const floorShape = new THREE.Shape();\n  floorShape.moveTo(0, 0);\n  floorShape.lineTo(12.43, 0);\n  floorShape.lineTo(12.43, 5.575);\n  floorShape.lineTo(6.215, 5.575);\n  floorShape.lineTo(6.215, 10.856);\n  floorShape.lineTo(0, 10.856);\n  floorShape.lineTo(0, 0);\n\n  const floorGeometry = new THREE.ShapeGeometry(floorShape);\n  floor = new THREE.Mesh(floorGeometry, floorMaterial);\n  floor.rotation.x = -Math.PI / 2;\n  floor.receiveShadow = true;\n  roomGroup.add(floor);\n\n  // Draw room edges as lines for the L-shape\n  const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x88ccff, opacity: 0.8, transparent: true });\n\n  // Floor outline\n  const floorOutline = [\n    [0, 0, 0], [12.43, 0, 0], [12.43, 5.575, 0], [6.215, 5.575, 0],\n    [6.215, 10.856, 0], [0, 10.856, 0], [0, 0, 0]\n  ];\n  const floorPoints = floorOutline.map(p => btToThree(p as BT_Vector3));\n  const floorLineGeom = new THREE.BufferGeometry().setFromPoints(floorPoints);\n  roomGroup.add(new THREE.Line(floorLineGeom, edgeMaterial));\n\n  // Ceiling outline\n  const ceilHeight = 4.877;\n  const ceilOutline = [\n    [0, 2.348, ceilHeight], [12.43, 2.348, ceilHeight], [12.43, 5.575, ceilHeight],\n    [6.215, 5.575, ceilHeight], [6.215, 10.856, ceilHeight], [0, 10.856, ceilHeight],\n    [0, 2.348, ceilHeight]\n  ];\n  const ceilPoints = ceilOutline.map(p => btToThree(p as BT_Vector3));\n  const ceilLineGeom = new THREE.BufferGeometry().setFromPoints(ceilPoints);\n  roomGroup.add(new THREE.Line(ceilLineGeom, edgeMaterial));\n\n  // Vertical edges at corners\n  const verticalEdges = [\n    [[0, 0, 0], [0, 0, 2.934]],\n    [[0, 0, 2.934], [0, 2.348, ceilHeight]],\n    [[12.43, 0, 0], [12.43, 0, 2.934]],\n    [[12.43, 0, 2.934], [12.43, 2.348, ceilHeight]],\n    [[12.43, 5.575, 0], [12.43, 5.575, ceilHeight]],\n    [[6.215, 5.575, 0], [6.215, 5.575, ceilHeight]],\n    [[6.215, 10.856, 0], [6.215, 10.856, ceilHeight]],\n    [[0, 10.856, 0], [0, 10.856, ceilHeight]],\n    [[0, 2.348, ceilHeight], [0, 10.856, ceilHeight]],\n  ];\n  verticalEdges.forEach(([p1, p2]) => {\n    const points = [btToThree(p1 as BT_Vector3), btToThree(p2 as BT_Vector3)];\n    const geom = new THREE.BufferGeometry().setFromPoints(points);\n    roomGroup.add(new THREE.Line(geom, edgeMaterial));\n  });\n\n  // Front slope edge\n  const slopeEdge = [[0, 0, 2.934], [12.43, 0, 2.934]];\n  const slopePoints = slopeEdge.map(p => btToThree(p as BT_Vector3));\n  const slopeGeom = new THREE.BufferGeometry().setFromPoints(slopePoints);\n  roomGroup.add(new THREE.Line(slopeGeom, edgeMaterial));\n}\n\n/**\n * Build the room visualization for Shoebox room\n */\nfunction buildShoeboxRoomVisuals(): void {\n  const floorGeometry = new THREE.PlaneGeometry(ROOM_WIDTH, ROOM_DEPTH);\n  floor = new THREE.Mesh(floorGeometry, floorMaterial);\n  floor.rotation.x = -Math.PI / 2;\n  floor.position.set(ROOM_WIDTH / 2, 0, ROOM_DEPTH / 2);\n  floor.receiveShadow = true;\n  roomGroup.add(floor);\n\n  // Room edges (wireframe box)\n  const roomBoxGeometry = new THREE.BoxGeometry(ROOM_WIDTH, ROOM_HEIGHT, ROOM_DEPTH);\n  const roomEdges = new THREE.EdgesGeometry(roomBoxGeometry);\n  const roomWireframe = new THREE.LineSegments(\n    roomEdges,\n    new THREE.LineBasicMaterial({ color: 0x88ccff, opacity: 0.8, transparent: true })\n  );\n  roomWireframe.position.set(ROOM_WIDTH / 2, ROOM_HEIGHT / 2, ROOM_DEPTH / 2);\n  roomGroup.add(roomWireframe);\n}\n\n/**\n * Build the room visualization for Auditorium (fan-shaped with stage)\n */\nfunction buildAuditoriumRoomVisuals(): void {\n  const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x88ccff, opacity: 0.8, transparent: true });\n\n  // Build floor from the auditorium geometry\n  // The auditorium has a sloped audience floor and a flat stage\n  // We'll create a simplified floor visualization\n\n  // Stage floor (flat, near origin)\n  const stageFloorGeom = new THREE.PlaneGeometry(3.5, 16);\n  const stageMesh = new THREE.Mesh(stageFloorGeom, floorMaterial.clone());\n  stageMesh.material.color.setHex(0x554455); // Slightly different color for stage\n  stageMesh.rotation.x = -Math.PI / 2;\n  stageMesh.position.set(1.75, 0, 6.776); // Center of stage area\n  roomGroup.add(stageMesh);\n\n  // Main audience floor - simplified as a large plane (actual geometry is sloped)\n  // Audience area spans from ~3.6 to ~26 in X, -4.5 to 18 in Y\n  const audienceFloorGeom = new THREE.PlaneGeometry(22, 23);\n  floor = new THREE.Mesh(audienceFloorGeom, floorMaterial);\n  floor.rotation.x = -Math.PI / 2;\n  floor.position.set(14.5, 0.3, 6.776); // Center of audience area, slightly elevated\n  floor.receiveShadow = true;\n  roomGroup.add(floor);\n\n  // Draw major boundary edges for the auditorium shape\n  // Fan-shaped outline with stage\n\n  // Stage area edges\n  const stageOutline: [number, number, number][] = [\n    [0, 0, 0], [0, 13.552, 0], [3.388, 14.907, 0], [3.64, 14.278, 0],\n    [3.64, -0.726, 0], [3.388, -1.355, 0], [0, 0, 0]\n  ];\n  const stagePoints = stageOutline.map(p => btToThree(p as BT_Vector3));\n  const stageLineGeom = new THREE.BufferGeometry().setFromPoints(stagePoints);\n  roomGroup.add(new THREE.Line(stageLineGeom, edgeMaterial));\n\n  // Main audience area floor boundary (fan shape)\n  const audienceOutline: [number, number, number][] = [\n    [3.64, -0.726, 0], [3.64, 14.278, 0],\n    [13.077, 18.053, 0.072], [23.24, 18.053, 0.572],\n    [25.27, 13.552, 0.572], [25.95, 6.776, 0.572],\n    [25.27, 0, 0.572], [23.24, -4.5, 0.572],\n    [13.077, -4.5, 0.072], [3.64, -0.726, 0]\n  ];\n  const audiencePoints = audienceOutline.map(p => btToThree(p as BT_Vector3));\n  const audienceLineGeom = new THREE.BufferGeometry().setFromPoints(audiencePoints);\n  roomGroup.add(new THREE.Line(audienceLineGeom, edgeMaterial));\n\n  // Ceiling outline at height ~8.24m (flat section) and ~4.74m (stage ceiling)\n  const ceilingOutline: [number, number, number][] = [\n    [0, 0, 4.743], [0, 13.552, 4.743], [3.388, 14.907, 4.743], [3.64, 14.278, 4.743],\n    [13.077, 18.053, 7.493], [15.077, 18.053, 8.243],\n    [23.24, 18.053, 8.243], [25.27, 13.552, 8.243], [25.95, 6.776, 8.243],\n    [25.27, 0, 8.243], [23.24, -4.5, 8.243], [15.077, -4.5, 8.243],\n    [13.077, -4.5, 7.493], [3.64, -0.726, 4.743], [3.388, -1.355, 4.743],\n    [0, 0, 4.743]\n  ];\n  const ceilingPoints = ceilingOutline.map(p => btToThree(p as BT_Vector3));\n  const ceilingLineGeom = new THREE.BufferGeometry().setFromPoints(ceilingPoints);\n  roomGroup.add(new THREE.Line(ceilingLineGeom, edgeMaterial));\n\n  // Vertical edges at key corners\n  const verticalEdges: [[number, number, number], [number, number, number]][] = [\n    [[0, 0, 0], [0, 0, 4.743]],\n    [[0, 13.552, 0], [0, 13.552, 4.743]],\n    [[3.388, 14.907, 0], [3.388, 14.907, 4.743]],\n    [[3.388, -1.355, 0], [3.388, -1.355, 4.743]],\n    [[3.64, 14.278, 0], [3.64, 14.278, 4.743]],\n    [[3.64, -0.726, 0], [3.64, -0.726, 4.743]],\n    [[13.077, 18.053, 0.072], [13.077, 18.053, 7.493]],\n    [[13.077, -4.5, 0.072], [13.077, -4.5, 7.493]],\n    [[23.24, 18.053, 0.572], [23.24, 18.053, 8.243]],\n    [[23.24, -4.5, 0.572], [23.24, -4.5, 8.243]],\n    [[25.27, 13.552, 0.572], [25.27, 13.552, 8.243]],\n    [[25.27, 0, 0.572], [25.27, 0, 8.243]],\n    [[25.95, 6.776, 0.572], [25.95, 6.776, 8.243]],\n  ];\n  verticalEdges.forEach(([p1, p2]) => {\n    const points = [btToThree(p1 as BT_Vector3), btToThree(p2 as BT_Vector3)];\n    const geom = new THREE.BufferGeometry().setFromPoints(points);\n    roomGroup.add(new THREE.Line(geom, edgeMaterial));\n  });\n\n  // Sloped ceiling edges connecting stage ceiling to main ceiling\n  const slopedEdges: [[number, number, number], [number, number, number]][] = [\n    [[3.64, 14.278, 4.743], [13.077, 18.053, 7.493]],\n    [[3.64, -0.726, 4.743], [13.077, -4.5, 7.493]],\n    [[13.077, 18.053, 7.493], [15.077, 18.053, 8.243]],\n    [[13.077, -4.5, 7.493], [15.077, -4.5, 8.243]],\n  ];\n  slopedEdges.forEach(([p1, p2]) => {\n    const points = [btToThree(p1 as BT_Vector3), btToThree(p2 as BT_Vector3)];\n    const geom = new THREE.BufferGeometry().setFromPoints(points);\n    roomGroup.add(new THREE.Line(geom, edgeMaterial));\n  });\n}\n\n/**\n * Clear all objects from the room group (except grid)\n */\nfunction clearRoomVisuals(): void {\n  // Remove all children except we'll rebuild everything\n  while (roomGroup.children.length > 0) {\n    const child = roomGroup.children[0];\n    roomGroup.remove(child);\n    if (child instanceof THREE.Mesh || child instanceof THREE.Line || child instanceof THREE.LineSegments) {\n      (child as THREE.Mesh).geometry?.dispose();\n    }\n  }\n}\n\n/**\n * Switch to a different room type\n */\nfunction switchRoom(roomType: RoomType): void {\n  if (roomType === currentRoomType) return;\n\n  currentRoomType = roomType;\n\n  // Update dimensions based on room type\n  if (roomType === 'concord') {\n    ROOM_WIDTH = 12.43;\n    ROOM_DEPTH = 10.86;\n    ROOM_HEIGHT = 4.88;\n    roomPolygons = createConcordRoom();\n    sourcePos = [3.7, 9.9, 1.0];\n    listenerPos = [10.8, 3.8, 1.2];\n  } else if (roomType === 'auditorium') {\n    ROOM_WIDTH = 26;\n    ROOM_DEPTH = 23;\n    ROOM_HEIGHT = 8.25;\n    roomPolygons = createAuditoriumRoom();\n    // Source on stage, listener in audience\n    sourcePos = [1.5, 6.8, 1.5];\n    listenerPos = [18, 6.8, 1.5];\n  } else {\n    ROOM_WIDTH = SHOEBOX_WIDTH;\n    ROOM_DEPTH = SHOEBOX_DEPTH;\n    ROOM_HEIGHT = SHOEBOX_HEIGHT;\n    roomPolygons = createShoeboxRoom(ROOM_WIDTH, ROOM_DEPTH, ROOM_HEIGHT);\n    sourcePos = [ROOM_WIDTH * 0.7, ROOM_DEPTH * 0.6, 1.5];\n    listenerPos = [ROOM_WIDTH * 0.3, ROOM_DEPTH * 0.3, 1.2];\n  }\n\n  // Update source and listener\n  source = new Source3D(sourcePos);\n  listener.moveTo(listenerPos);\n\n  // Update mesh positions\n  sourceMesh.position.copy(btToThree(sourcePos));\n  sourceGlow.position.copy(btToThree(sourcePos));\n  listenerMesh.position.copy(btToThree(listenerPos));\n\n  // Rebuild room visuals\n  clearRoomVisuals();\n  if (roomType === 'concord') {\n    buildConcordRoomVisuals();\n  } else if (roomType === 'auditorium') {\n    buildAuditoriumRoomVisuals();\n  } else {\n    buildShoeboxRoomVisuals();\n  }\n\n  // Rebuild grid\n  const gridHelper = new THREE.GridHelper(\n    Math.max(ROOM_WIDTH, ROOM_DEPTH),\n    Math.max(ROOM_WIDTH, ROOM_DEPTH),\n    0x444466,\n    0x333344\n  );\n  gridHelper.position.set(ROOM_WIDTH / 2, 0.01, ROOM_DEPTH / 2);\n  roomGroup.add(gridHelper);\n\n  // Update camera to fit new room\n  camera.position.set(\n    ROOM_WIDTH * 1.2,\n    ROOM_HEIGHT * 1.5,\n    ROOM_DEPTH * 1.2\n  );\n  controls.target.set(ROOM_WIDTH / 2, ROOM_HEIGHT / 3, ROOM_DEPTH / 2);\n  controls.update();\n\n  // Recreate solver and update paths\n  recreateSolver();\n  updatePaths();\n\n  const roomNames: Record<RoomType, string> = {\n    'concord': 'Concord (L-shaped)',\n    'shoebox': 'Shoebox',\n    'auditorium': 'Auditorium (fan-shaped)'\n  };\n  console.log(`Switched to ${roomNames[roomType]} room`);\n}\n\n// Build initial room visuals\nbuildConcordRoomVisuals();\n\n// Grid helper on floor\nconst gridHelper = new THREE.GridHelper(\n  Math.max(ROOM_WIDTH, ROOM_DEPTH),\n  Math.max(ROOM_WIDTH, ROOM_DEPTH),\n  0x444466,\n  0x333344\n);\ngridHelper.position.set(ROOM_WIDTH / 2, 0.01, ROOM_DEPTH / 2);\nroomGroup.add(gridHelper);\n\nscene.add(roomGroup);\n\n// ============================================================================\n// Source and Listener Visualization\n// ============================================================================\n\n// Source sphere (red)\nconst sourceGeometry = new THREE.SphereGeometry(0.15, 32, 32);\nconst sourceMaterial = new THREE.MeshStandardMaterial({\n  color: 0xff4444,\n  emissive: 0xff2222,\n  emissiveIntensity: 0.3,\n  roughness: 0.3,\n  metalness: 0.5\n});\nconst sourceMesh = new THREE.Mesh(sourceGeometry, sourceMaterial);\nsourceMesh.position.copy(btToThree(sourcePos));\nscene.add(sourceMesh);\n\n// Source glow\nconst sourceGlowGeometry = new THREE.SphereGeometry(0.25, 32, 32);\nconst sourceGlowMaterial = new THREE.MeshBasicMaterial({\n  color: 0xff4444,\n  transparent: true,\n  opacity: 0.2\n});\nconst sourceGlow = new THREE.Mesh(sourceGlowGeometry, sourceGlowMaterial);\nsourceGlow.position.copy(btToThree(sourcePos));\nscene.add(sourceGlow);\n\n// Listener sphere (blue)\nconst listenerGeometry = new THREE.SphereGeometry(0.12, 32, 32);\nconst listenerMaterial = new THREE.MeshStandardMaterial({\n  color: 0x4488ff,\n  emissive: 0x2266ff,\n  emissiveIntensity: 0.3,\n  roughness: 0.3,\n  metalness: 0.5\n});\nconst listenerMesh = new THREE.Mesh(listenerGeometry, listenerMaterial);\nlistenerMesh.position.copy(btToThree(listenerPos));\nscene.add(listenerMesh);\n\n// ============================================================================\n// Reflection Paths Visualization\n// ============================================================================\n\nconst pathsGroup = new THREE.Group();\nscene.add(pathsGroup);\n\nconst beamsGroup = new THREE.Group();\nscene.add(beamsGroup);\n\nfunction clearVisualization(): void {\n  // Clear paths\n  while (pathsGroup.children.length > 0) {\n    const child = pathsGroup.children[0];\n    pathsGroup.remove(child);\n    if (child instanceof THREE.Line || child instanceof THREE.Mesh) {\n      (child as THREE.Mesh).geometry?.dispose();\n      const mat = (child as THREE.Mesh).material;\n      if (Array.isArray(mat)) mat.forEach(m => m.dispose());\n      else if (mat) (mat as THREE.Material).dispose();\n    }\n  }\n\n  // Clear beams\n  while (beamsGroup.children.length > 0) {\n    const child = beamsGroup.children[0];\n    beamsGroup.remove(child);\n    if (child instanceof THREE.Mesh || child instanceof THREE.Line) {\n      (child as THREE.Mesh).geometry?.dispose();\n      const mat = (child as THREE.Mesh).material;\n      if (Array.isArray(mat)) mat.forEach(m => m.dispose());\n      else if (mat) (mat as THREE.Material).dispose();\n    }\n  }\n}\n\nfunction updatePaths(): void {\n  clearVisualization();\n\n  // Get paths from solver with timing\n  const solveStart = performance.now();\n  const paths = solver.getPaths(listener);\n  const solveTime = performance.now() - solveStart;\n  smoothedComputeTime = smoothedComputeTime * (1 - TIMING_SMOOTHING) + solveTime * TIMING_SMOOTHING;\n\n  const metrics = solver.getMetrics();\n\n  // Draw based on visualization mode\n  const renderStart = performance.now();\n\n  if (visualizationMode === 'beams') {\n    // Draw beam cones\n    const beams = solver.getBeamsForVisualization(currentReflectionOrder);\n    for (const beam of beams) {\n      drawBeamCone(beam);\n    }\n  } else {\n    // Draw ray paths (default)\n    for (const path of paths) {\n      drawPath(path);\n    }\n  }\n\n  const renderTime = performance.now() - renderStart;\n  smoothedRenderTime = smoothedRenderTime * (1 - TIMING_SMOOTHING) + renderTime * TIMING_SMOOTHING;\n\n  // Update UI\n  updateUI(paths.length, metrics);\n}\n\nfunction drawPath(path: ReflectionPath3D): void {\n  const order = getPathReflectionOrder(path);\n  const colorIndex = Math.min(order, PATH_COLORS.length - 1);\n  const color = PATH_COLORS[colorIndex];\n\n  // Create points array\n  const points: THREE.Vector3[] = path.map(p => btToThree(p.position));\n\n  // Create line geometry\n  const geometry = new THREE.BufferGeometry().setFromPoints(points);\n\n  // Line material with varying opacity based on order\n  const opacity = Math.max(0.3, 0.8 - order * 0.15);\n  const material = new THREE.LineBasicMaterial({\n    color,\n    transparent: true,\n    opacity,\n    linewidth: 2 // Note: linewidth > 1 only works on some systems\n  });\n\n  const line = new THREE.Line(geometry, material);\n  pathsGroup.add(line);\n\n  // Add small spheres at reflection points\n  for (let i = 1; i < path.length - 1; i++) {\n    const pointGeom = new THREE.SphereGeometry(0.03, 8, 8);\n    const pointMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.6 });\n    const pointMesh = new THREE.Mesh(pointGeom, pointMat);\n    pointMesh.position.copy(btToThree(path[i].position));\n    pathsGroup.add(pointMesh);\n  }\n}\n\n/**\n * Draw a beam as a cone from virtual source through aperture polygon\n */\nfunction drawBeamCone(beam: BeamVisualizationData): void {\n  const colorIndex = Math.min(beam.reflectionOrder, PATH_COLORS.length - 1);\n  const color = PATH_COLORS[colorIndex];\n  const opacity = Math.max(0.08, 0.2 - beam.reflectionOrder * 0.03);\n\n  const vs = btToThree(beam.virtualSource);\n  const apertureVerts = beam.apertureVertices.map(v => btToThree(v));\n\n  // Draw edges from virtual source to each aperture vertex\n  for (let i = 0; i < apertureVerts.length; i++) {\n    const edgeGeom = new THREE.BufferGeometry().setFromPoints([vs, apertureVerts[i]]);\n    const edgeMat = new THREE.LineBasicMaterial({\n      color,\n      transparent: true,\n      opacity: opacity * 2\n    });\n    beamsGroup.add(new THREE.Line(edgeGeom, edgeMat));\n  }\n\n  // Draw aperture polygon outline\n  const apertureOutline = [...apertureVerts, apertureVerts[0]];\n  const outlineGeom = new THREE.BufferGeometry().setFromPoints(apertureOutline);\n  const outlineMat = new THREE.LineBasicMaterial({\n    color,\n    transparent: true,\n    opacity: opacity * 3\n  });\n  beamsGroup.add(new THREE.Line(outlineGeom, outlineMat));\n\n  // Draw triangular faces of the cone (from virtual source to each aperture edge)\n  for (let i = 0; i < apertureVerts.length; i++) {\n    const next = (i + 1) % apertureVerts.length;\n    const v0 = vs;\n    const v1 = apertureVerts[i];\n    const v2 = apertureVerts[next];\n\n    const faceGeom = new THREE.BufferGeometry();\n    const vertices = new Float32Array([\n      v0.x, v0.y, v0.z,\n      v1.x, v1.y, v1.z,\n      v2.x, v2.y, v2.z\n    ]);\n    faceGeom.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n    faceGeom.computeVertexNormals();\n\n    const faceMat = new THREE.MeshBasicMaterial({\n      color,\n      transparent: true,\n      opacity,\n      side: THREE.DoubleSide,\n      depthWrite: false\n    });\n\n    beamsGroup.add(new THREE.Mesh(faceGeom, faceMat));\n  }\n\n  // Draw virtual source as small sphere\n  const vsGeom = new THREE.SphereGeometry(0.05, 8, 8);\n  const vsMat = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.6 });\n  const vsMesh = new THREE.Mesh(vsGeom, vsMat);\n  vsMesh.position.copy(vs);\n  beamsGroup.add(vsMesh);\n}\n\n// ============================================================================\n// UI Updates\n// ============================================================================\n\n/**\n * Format time for display - always in ms with appropriate precision\n */\nfunction formatTime(ms: number): string {\n  if (ms < 1) {\n    return ms.toFixed(2) + ' ms';\n  } else if (ms < 10) {\n    return ms.toFixed(1) + ' ms';\n  } else {\n    return Math.round(ms) + ' ms';\n  }\n}\n\nfunction updateUI(pathCount: number, metrics: ReturnType<typeof solver.getMetrics>): void {\n  const pathCountEl = document.getElementById('pathCount');\n  const raycastsEl = document.getElementById('raycasts');\n  const leafNodesEl = document.getElementById('leafNodes');\n  const failPlaneEl = document.getElementById('failPlane');\n  const skipSphereEl = document.getElementById('skipSphere');\n  const precomputeTimeEl = document.getElementById('precomputeTime');\n  const computeTimeEl = document.getElementById('computeTime');\n  const renderTimeEl = document.getElementById('renderTime');\n\n  if (pathCountEl) pathCountEl.textContent = pathCount.toString();\n  if (raycastsEl) raycastsEl.textContent = metrics.raycastCount.toString();\n  if (leafNodesEl) leafNodesEl.textContent = metrics.totalLeafNodes.toString();\n\n  // Fail plane: hits / (hits + misses) - shows cache effectiveness\n  if (failPlaneEl) {\n    const total = metrics.failPlaneCacheHits + metrics.failPlaneCacheMisses;\n    if (total > 0) {\n      const hitRate = Math.round((metrics.failPlaneCacheHits / total) * 100);\n      failPlaneEl.textContent = `${metrics.failPlaneCacheHits} (${hitRate}%)`;\n    } else {\n      failPlaneEl.textContent = `${metrics.failPlaneCacheHits}`;\n    }\n  }\n\n  // Skip sphere: buckets skipped / total buckets\n  if (skipSphereEl) {\n    if (metrics.bucketsTotal > 0) {\n      const skipRate = Math.round((metrics.bucketsSkipped / metrics.bucketsTotal) * 100);\n      skipSphereEl.textContent = `${metrics.bucketsSkipped}/${metrics.bucketsTotal} (${skipRate}%)`;\n    } else {\n      skipSphereEl.textContent = '0';\n    }\n  }\n\n  if (precomputeTimeEl) precomputeTimeEl.textContent = formatTime(lastPrecomputeTime);\n  if (computeTimeEl) computeTimeEl.textContent = formatTime(smoothedComputeTime);\n  if (renderTimeEl) renderTimeEl.textContent = formatTime(smoothedRenderTime);\n\n  // Update position displays\n  updatePositionUI();\n}\n\nfunction updatePositionUI(): void {\n  const sourceXEl = document.getElementById('sourceX');\n  const sourceYEl = document.getElementById('sourceY');\n  const sourceZEl = document.getElementById('sourceZ');\n  const listenerXEl = document.getElementById('listenerX');\n  const listenerYEl = document.getElementById('listenerY');\n  const listenerZEl = document.getElementById('listenerZ');\n\n  if (sourceXEl) sourceXEl.textContent = sourcePos[0].toFixed(1);\n  if (sourceYEl) sourceYEl.textContent = sourcePos[1].toFixed(1);\n  if (sourceZEl) sourceZEl.textContent = sourcePos[2].toFixed(2);\n  if (listenerXEl) listenerXEl.textContent = listenerPos[0].toFixed(1);\n  if (listenerYEl) listenerYEl.textContent = listenerPos[1].toFixed(1);\n  if (listenerZEl) listenerZEl.textContent = listenerPos[2].toFixed(2);\n}\n\nfunction updateSourcePosition(axis: 'x' | 'y' | 'z', delta: number): void {\n  const margin = 0.3;\n  const idx = axis === 'x' ? 0 : axis === 'y' ? 1 : 2;\n  const maxVal = idx === 0 ? ROOM_WIDTH : idx === 1 ? ROOM_DEPTH : ROOM_HEIGHT;\n\n  sourcePos[idx] = Math.max(margin, Math.min(maxVal - margin, sourcePos[idx] + delta));\n  source = new Source3D(sourcePos);\n\n  // Update visualization\n  sourceMesh.position.copy(btToThree(sourcePos));\n  sourceGlow.position.copy(btToThree(sourcePos));\n\n  // Recreate solver with new source position\n  recreateSolver();\n  updatePaths();\n}\n\nfunction updateListenerPosition(axis: 'x' | 'y' | 'z', delta: number): void {\n  const margin = 0.3;\n  const idx = axis === 'x' ? 0 : axis === 'y' ? 1 : 2;\n  const maxVal = idx === 0 ? ROOM_WIDTH : idx === 1 ? ROOM_DEPTH : ROOM_HEIGHT;\n\n  listenerPos[idx] = Math.max(margin, Math.min(maxVal - margin, listenerPos[idx] + delta));\n  listener.moveTo(listenerPos);\n\n  // Update visualization\n  listenerMesh.position.copy(btToThree(listenerPos));\n\n  // Update paths\n  updatePaths();\n}\n\n// Set up coordinate button handlers\ndocument.querySelectorAll('.coord-btn').forEach(btn => {\n  btn.addEventListener('click', (e) => {\n    e.stopPropagation();\n    const target = (btn as HTMLElement).dataset.target;\n    const axis = (btn as HTMLElement).dataset.axis as 'x' | 'y' | 'z';\n    const delta = parseFloat((btn as HTMLElement).dataset.delta || '0');\n\n    if (target === 'source') {\n      updateSourcePosition(axis, delta);\n    } else if (target === 'listener') {\n      updateListenerPosition(axis, delta);\n    }\n  });\n});\n\n// ============================================================================\n// Interaction - Draggable Source and Listener\n// ============================================================================\n\nconst raycaster = new THREE.Raycaster();\nconst mouse = new THREE.Vector2();\n\n// Drag state\ntype DragTarget = 'source' | 'listener' | null;\nlet dragTarget: DragTarget = null;\nlet isMouseDown = false;\nlet mouseDownPos = { x: 0, y: 0 };\nconst DRAG_THRESHOLD = 3; // pixels - smaller for more responsive drag detection\n\n// Throttling for performance\nlet lastPathUpdate = 0;\nlet lastUIUpdate = 0;\nconst PATH_UPDATE_THROTTLE = 16; // ~60fps for listener\nconst UI_UPDATE_THROTTLE = 50; // 20fps for UI text updates\nlet pendingSourceUpdate = false;\n\n// Drag intersection point\nconst intersectPoint = new THREE.Vector3();\n\n/**\n * Determine the best drag plane based on camera orientation.\n * - When looking from above (plan view), use horizontal plane (move in X/Y)\n * - When looking from side (section view), use vertical plane (move in X/Z or Y/Z)\n *\n * The key insight: we want to use a plane that is most perpendicular to the view direction.\n * This gives the most intuitive mouse-to-world mapping.\n */\nfunction getDragPlane(targetPos: BT_Vector3): THREE.Plane {\n  const cameraDir = new THREE.Vector3();\n  camera.getWorldDirection(cameraDir);\n\n  // Get camera's \"up\" component - how much are we looking down vs sideways?\n  // cameraDir.y: -1 = looking straight down, 0 = looking horizontal, 1 = looking up\n  const verticalComponent = Math.abs(cameraDir.y);\n\n  // Threshold for switching between horizontal and vertical planes\n  // Below 0.5 means camera is more horizontal than vertical\n  const useHorizontalPlane = verticalComponent > 0.5;\n\n  // Three.js coordinates: X = width, Y = height (up), Z = depth\n  // BeamTrace coords:    X = width, Y = depth, Z = height (up)\n  const threePos = btToThree(targetPos);\n\n  if (useHorizontalPlane) {\n    // Plan view - horizontal plane at object's height\n    // Allows dragging in X and Z (world), which maps to X and Y (BeamTrace)\n    return new THREE.Plane(new THREE.Vector3(0, 1, 0), -threePos.y);\n  } else {\n    // Section view - vertical plane perpendicular to horizontal camera direction\n    // This allows dragging to change height (Y in Three.js, Z in BeamTrace)\n\n    // Project camera direction onto XZ plane (remove vertical component)\n    const horizontalDir = new THREE.Vector3(cameraDir.x, 0, cameraDir.z).normalize();\n\n    // The plane normal should face the camera (perpendicular to view)\n    // This creates a \"screen-aligned\" vertical plane at the object's position\n    const planeNormal = horizontalDir.clone();\n\n    // Calculate plane constant: -dot(normal, point)\n    const constant = -planeNormal.dot(threePos);\n\n    return new THREE.Plane(planeNormal, constant);\n  }\n}\n\nfunction updateMousePosition(event: MouseEvent): void {\n  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;\n}\n\nfunction getHoveredObject(): DragTarget {\n  raycaster.setFromCamera(mouse, camera);\n\n  // Check source first (larger hitbox)\n  const sourceHits = raycaster.intersectObject(sourceMesh);\n  if (sourceHits.length > 0) return 'source';\n\n  const listenerHits = raycaster.intersectObject(listenerMesh);\n  if (listenerHits.length > 0) return 'listener';\n\n  return null;\n}\n\nfunction updateCursor(): void {\n  const hovered = getHoveredObject();\n  renderer.domElement.style.cursor = hovered ? 'grab' : 'default';\n}\n\n// Optimized path update - skips UI for real-time dragging\nfunction updatePathsRealtime(skipUI: boolean = false): void {\n  clearVisualization();\n\n  // Get paths from solver with timing\n  const solveStart = performance.now();\n  const paths = solver.getPaths(listener);\n  const solveTime = performance.now() - solveStart;\n  smoothedComputeTime = smoothedComputeTime * (1 - TIMING_SMOOTHING) + solveTime * TIMING_SMOOTHING;\n\n  // Draw based on visualization mode with timing\n  const renderStart = performance.now();\n\n  if (visualizationMode === 'beams') {\n    const beams = solver.getBeamsForVisualization(currentReflectionOrder);\n    for (const beam of beams) {\n      drawBeamCone(beam);\n    }\n  } else {\n    for (const path of paths) {\n      drawPath(path);\n    }\n  }\n\n  const renderTime = performance.now() - renderStart;\n  smoothedRenderTime = smoothedRenderTime * (1 - TIMING_SMOOTHING) + renderTime * TIMING_SMOOTHING;\n\n  // Throttle UI updates\n  if (!skipUI) {\n    const metrics = solver.getMetrics();\n    updateUI(paths.length, metrics);\n  }\n}\n\n// Deferred source update (precompute is expensive)\nfunction scheduleSourceUpdate(): void {\n  pendingSourceUpdate = true;\n}\n\nfunction processSourceUpdate(): void {\n  if (!pendingSourceUpdate) return;\n  pendingSourceUpdate = false;\n\n  source = new Source3D(sourcePos);\n  recreateSolver();\n  updatePathsRealtime(false);\n}\n\nrenderer.domElement.addEventListener('mousedown', (event: MouseEvent) => {\n  mouseDownPos = { x: event.clientX, y: event.clientY };\n  isMouseDown = true;\n\n  updateMousePosition(event);\n  const target = getHoveredObject();\n\n  if (target) {\n    dragTarget = target;\n    controls.enabled = false; // Disable orbit controls while dragging\n    renderer.domElement.style.cursor = 'grabbing';\n  }\n});\n\nrenderer.domElement.addEventListener('mousemove', (event: MouseEvent) => {\n  updateMousePosition(event);\n\n  if (!isMouseDown) {\n    // Just hovering - update cursor\n    updateCursor();\n    return;\n  }\n\n  if (!dragTarget) {\n    // Check if we've moved enough to start an orbit drag\n    const dx = event.clientX - mouseDownPos.x;\n    const dy = event.clientY - mouseDownPos.y;\n    if (Math.sqrt(dx * dx + dy * dy) > DRAG_THRESHOLD) {\n      // Let OrbitControls handle it\n    }\n    return;\n  }\n\n  // Dragging source or listener - raycast to appropriate plane based on camera view\n  raycaster.setFromCamera(mouse, camera);\n\n  const currentPos = dragTarget === 'source' ? sourcePos : listenerPos;\n  const plane = getDragPlane(currentPos);\n\n  if (raycaster.ray.intersectPlane(plane, intersectPoint)) {\n    const margin = 0.3;\n\n    // Clamp intersect point to room bounds\n    // Three.js: X = width, Y = height, Z = depth\n    // BeamTrace: X = width, Y = depth, Z = height\n    const newX = Math.max(margin, Math.min(ROOM_WIDTH - margin, intersectPoint.x));\n    const newY = Math.max(margin, Math.min(ROOM_DEPTH - margin, intersectPoint.z)); // Three.js Z -> BeamTrace Y\n    const newZ = Math.max(margin, Math.min(ROOM_HEIGHT - margin, intersectPoint.y)); // Three.js Y -> BeamTrace Z\n\n    if (dragTarget === 'listener') {\n      // Real-time listener updates\n      listenerPos = [newX, newY, newZ];\n      listener.moveTo(listenerPos);\n      listenerMesh.position.set(newX, newZ, newY); // Convert back to Three.js coords\n\n      // Throttle path updates\n      const now = performance.now();\n      if (now - lastPathUpdate > PATH_UPDATE_THROTTLE) {\n        lastPathUpdate = now;\n        updatePathsRealtime(now - lastUIUpdate < UI_UPDATE_THROTTLE);\n        if (now - lastUIUpdate >= UI_UPDATE_THROTTLE) {\n          lastUIUpdate = now;\n        }\n      }\n    } else {\n      // Source: update visual immediately, defer expensive precompute\n      sourcePos = [newX, newY, newZ];\n      sourceMesh.position.set(newX, newZ, newY); // Convert back to Three.js coords\n      sourceGlow.position.set(newX, newZ, newY);\n      scheduleSourceUpdate();\n\n      // Update position display at throttled rate\n      const now = performance.now();\n      if (now - lastUIUpdate > UI_UPDATE_THROTTLE) {\n        lastUIUpdate = now;\n        updatePositionUI();\n      }\n    }\n  }\n});\n\nrenderer.domElement.addEventListener('mouseup', (event: MouseEvent) => {\n  const wasDragging = dragTarget !== null;\n\n  if (dragTarget === 'source') {\n    // Process deferred source update on release\n    processSourceUpdate();\n  }\n\n  dragTarget = null;\n  isMouseDown = false;\n  controls.enabled = true;\n\n  updateMousePosition(event);\n  updateCursor();\n\n  // If we weren't dragging an object, check for floor click\n  if (!wasDragging) {\n    const dx = event.clientX - mouseDownPos.x;\n    const dy = event.clientY - mouseDownPos.y;\n    const didMove = Math.sqrt(dx * dx + dy * dy) > DRAG_THRESHOLD;\n\n    if (!didMove) {\n      // Click on floor - move listener\n      raycaster.setFromCamera(mouse, camera);\n      const intersects = raycaster.intersectObject(floor);\n\n      if (intersects.length > 0) {\n        const point = intersects[0].point;\n        const margin = 0.3;\n        const x = Math.max(margin, Math.min(ROOM_WIDTH - margin, point.x));\n        const z = Math.max(margin, Math.min(ROOM_DEPTH - margin, point.z));\n\n        listenerPos = [x, z, listenerPos[2]];\n        listener.moveTo(listenerPos);\n        listenerMesh.position.set(x, listenerPos[2], z);\n\n        updatePaths();\n      }\n    }\n  }\n});\n\n// Handle mouse leaving the canvas\nrenderer.domElement.addEventListener('mouseleave', () => {\n  if (dragTarget === 'source') {\n    processSourceUpdate();\n  }\n  dragTarget = null;\n  isMouseDown = false;\n  controls.enabled = true;\n  renderer.domElement.style.cursor = 'default';\n});\n\n// ============================================================================\n// Window Resize\n// ============================================================================\n\nfunction onWindowResize(): void {\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n}\n\nwindow.addEventListener('resize', onWindowResize);\n\n// ============================================================================\n// Reflection Order Controls\n// ============================================================================\n\nfunction updateOrderUI(): void {\n  const orderValueEl = document.getElementById('orderValue');\n  const orderUpBtn = document.getElementById('orderUp') as HTMLButtonElement;\n  const orderDownBtn = document.getElementById('orderDown') as HTMLButtonElement;\n\n  if (orderValueEl) orderValueEl.textContent = currentReflectionOrder.toString();\n  if (orderUpBtn) orderUpBtn.disabled = currentReflectionOrder >= MAX_REFLECTION_ORDER;\n  if (orderDownBtn) orderDownBtn.disabled = currentReflectionOrder <= MIN_REFLECTION_ORDER;\n\n  // Update legend to show which orders are visible\n  for (let i = 0; i <= 4; i++) {\n    const legendItem = document.getElementById(`legend-${i}`);\n    if (legendItem) {\n      // Order 4 in legend represents 4+ orders\n      const orderThreshold = i === 4 ? 4 : i;\n      if (orderThreshold > currentReflectionOrder) {\n        legendItem.classList.add('dimmed');\n      } else {\n        legendItem.classList.remove('dimmed');\n      }\n    }\n  }\n}\n\nfunction changeReflectionOrder(delta: number): void {\n  const newOrder = currentReflectionOrder + delta;\n  if (newOrder >= MIN_REFLECTION_ORDER && newOrder <= MAX_REFLECTION_ORDER) {\n    currentReflectionOrder = newOrder;\n    recreateSolver();\n    updateOrderUI();\n    updatePaths();\n  }\n}\n\n// Button controls\ndocument.getElementById('orderUp')?.addEventListener('click', (e) => {\n  e.stopPropagation();\n  changeReflectionOrder(1);\n});\n\ndocument.getElementById('orderDown')?.addEventListener('click', (e) => {\n  e.stopPropagation();\n  changeReflectionOrder(-1);\n});\n\n// Toggle visualization mode\nfunction toggleVisualizationMode(): void {\n  visualizationMode = visualizationMode === 'paths' ? 'beams' : 'paths';\n  const toggleBtn = document.getElementById('toggleView');\n  if (toggleBtn) {\n    toggleBtn.textContent = visualizationMode === 'paths' ? 'Paths' : 'Beams';\n  }\n  updatePaths();\n}\n\ndocument.getElementById('toggleView')?.addEventListener('click', (e) => {\n  e.stopPropagation();\n  toggleVisualizationMode();\n});\n\n// Room selector handler\ndocument.getElementById('roomSelect')?.addEventListener('change', (e) => {\n  const select = e.target as HTMLSelectElement;\n  switchRoom(select.value as RoomType);\n});\n\n// Keyboard controls\nwindow.addEventListener('keydown', (e) => {\n  if (e.key === '+' || e.key === '=' || e.key === 'ArrowUp') {\n    changeReflectionOrder(1);\n  } else if (e.key === '-' || e.key === '_' || e.key === 'ArrowDown') {\n    changeReflectionOrder(-1);\n  } else if (e.key === 'b' || e.key === 'B') {\n    toggleVisualizationMode();\n  }\n});\n\n// ============================================================================\n// Animation Loop\n// ============================================================================\n\nlet frameCount = 0;\nlet lastFPSUpdate = performance.now();\n\nfunction animate(): void {\n  requestAnimationFrame(animate);\n\n  // Update controls\n  controls.update();\n\n  // FPS counter\n  frameCount++;\n  const now = performance.now();\n  if (now - lastFPSUpdate >= 1000) {\n    const fpsEl = document.getElementById('fps');\n    if (fpsEl) fpsEl.textContent = frameCount.toString();\n    frameCount = 0;\n    lastFPSUpdate = now;\n  }\n\n  // Subtle source glow animation\n  const scale = 1 + Math.sin(now * 0.003) * 0.1;\n  sourceGlow.scale.setScalar(scale);\n\n  renderer.render(scene, camera);\n}\n\n// ============================================================================\n// Initialize\n// ============================================================================\n\n// Set initial camera position\ncamera.position.set(\n  ROOM_WIDTH * 1.2,\n  ROOM_HEIGHT * 1.5,\n  ROOM_DEPTH * 1.2\n);\ncontrols.target.set(ROOM_WIDTH / 2, ROOM_HEIGHT / 3, ROOM_DEPTH / 2);\ncontrols.update();\n\n// Initialize UI\nupdateOrderUI();\nupdatePositionUI();\n\n// Initial path calculation\nupdatePaths();\n\n// Start animation loop\nanimate();\n\nconsole.log('BeamTrace3D Demo initialized');\nconsole.log(`Room: ${currentRoomType === 'concord' ? 'Concord (L-shaped)' : 'Shoebox'} - ${ROOM_WIDTH.toFixed(2)}m x ${ROOM_DEPTH.toFixed(2)}m x ${ROOM_HEIGHT.toFixed(2)}m`);\nconsole.log(`Polygons: ${roomPolygons.length}`);\nconsole.log(`Max reflection order: ${MAX_REFLECTION_ORDER}`);\nconsole.log(`Leaf nodes: ${solver.getLeafNodeCount()}`);\n", "/**\n * 3D Vector operations for BeamTrace3D\n *\n * Vectors are represented as [x, y, z] tuples for performance.\n */\n\nexport type Vector3 = [number, number, number];\n\nexport const Vector3 = {\n  /**\n   * Create a new Vector3\n   */\n  create(x: number, y: number, z: number): Vector3 {\n    return [x, y, z];\n  },\n\n  /**\n   * Create a zero vector\n   */\n  zero(): Vector3 {\n    return [0, 0, 0];\n  },\n\n  /**\n   * Clone a vector\n   */\n  clone(v: Vector3): Vector3 {\n    return [v[0], v[1], v[2]];\n  },\n\n  /**\n   * Add two vectors\n   */\n  add(a: Vector3, b: Vector3): Vector3 {\n    return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];\n  },\n\n  /**\n   * Subtract vector b from vector a\n   */\n  subtract(a: Vector3, b: Vector3): Vector3 {\n    return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];\n  },\n\n  /**\n   * Scale a vector by a scalar\n   */\n  scale(v: Vector3, s: number): Vector3 {\n    return [v[0] * s, v[1] * s, v[2] * s];\n  },\n\n  /**\n   * Negate a vector\n   */\n  negate(v: Vector3): Vector3 {\n    return [-v[0], -v[1], -v[2]];\n  },\n\n  /**\n   * Dot product of two vectors\n   */\n  dot(a: Vector3, b: Vector3): number {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n  },\n\n  /**\n   * Cross product of two vectors (a \u00D7 b)\n   */\n  cross(a: Vector3, b: Vector3): Vector3 {\n    return [\n      a[1] * b[2] - a[2] * b[1],\n      a[2] * b[0] - a[0] * b[2],\n      a[0] * b[1] - a[1] * b[0]\n    ];\n  },\n\n  /**\n   * Squared length of a vector\n   */\n  lengthSquared(v: Vector3): number {\n    return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];\n  },\n\n  /**\n   * Length (magnitude) of a vector\n   */\n  length(v: Vector3): number {\n    return Math.sqrt(Vector3.lengthSquared(v));\n  },\n\n  /**\n   * Normalize a vector to unit length\n   * Returns zero vector if input has zero length\n   */\n  normalize(v: Vector3): Vector3 {\n    const len = Vector3.length(v);\n    if (len < 1e-10) return [0, 0, 0];\n    return [v[0] / len, v[1] / len, v[2] / len];\n  },\n\n  /**\n   * Linear interpolation between two vectors\n   */\n  lerp(a: Vector3, b: Vector3, t: number): Vector3 {\n    return [\n      a[0] + t * (b[0] - a[0]),\n      a[1] + t * (b[1] - a[1]),\n      a[2] + t * (b[2] - a[2])\n    ];\n  },\n\n  /**\n   * Distance between two points\n   */\n  distance(a: Vector3, b: Vector3): number {\n    return Vector3.length(Vector3.subtract(a, b));\n  },\n\n  /**\n   * Squared distance between two points (faster than distance)\n   */\n  distanceSquared(a: Vector3, b: Vector3): number {\n    return Vector3.lengthSquared(Vector3.subtract(a, b));\n  },\n\n  /**\n   * Check if two vectors are approximately equal\n   */\n  equals(a: Vector3, b: Vector3, epsilon: number = 1e-10): boolean {\n    return Math.abs(a[0] - b[0]) < epsilon &&\n           Math.abs(a[1] - b[1]) < epsilon &&\n           Math.abs(a[2] - b[2]) < epsilon;\n  },\n\n  /**\n   * Component-wise minimum\n   */\n  min(a: Vector3, b: Vector3): Vector3 {\n    return [\n      Math.min(a[0], b[0]),\n      Math.min(a[1], b[1]),\n      Math.min(a[2], b[2])\n    ];\n  },\n\n  /**\n   * Component-wise maximum\n   */\n  max(a: Vector3, b: Vector3): Vector3 {\n    return [\n      Math.max(a[0], b[0]),\n      Math.max(a[1], b[1]),\n      Math.max(a[2], b[2])\n    ];\n  },\n\n  /**\n   * Reflect vector v across a plane with given normal\n   * v' = v - 2(v\u00B7n)n\n   */\n  reflect(v: Vector3, normal: Vector3): Vector3 {\n    const d = 2 * Vector3.dot(v, normal);\n    return Vector3.subtract(v, Vector3.scale(normal, d));\n  },\n\n  /**\n   * Project vector a onto vector b\n   */\n  project(a: Vector3, b: Vector3): Vector3 {\n    const bLenSq = Vector3.lengthSquared(b);\n    if (bLenSq < 1e-10) return [0, 0, 0];\n    const scale = Vector3.dot(a, b) / bLenSq;\n    return Vector3.scale(b, scale);\n  },\n\n  /**\n   * Get the component of a perpendicular to b\n   */\n  reject(a: Vector3, b: Vector3): Vector3 {\n    return Vector3.subtract(a, Vector3.project(a, b));\n  },\n\n  /**\n   * Convert to string for debugging\n   */\n  toString(v: Vector3, precision: number = 4): string {\n    return `[${v[0].toFixed(precision)}, ${v[1].toFixed(precision)}, ${v[2].toFixed(precision)}]`;\n  }\n};\n", "/**\n * 3D Plane representation and operations for BeamTrace3D\n *\n * Plane is represented in implicit form: ax + by + cz + d = 0\n * where [a, b, c] is the normalized normal vector and d is the distance term.\n *\n * Points in front of the plane (positive side) satisfy ax + by + cz + d > 0\n */\n\nimport { Vector3 } from './vector3';\nimport { PointClassification } from './types';\n\n/**\n * 3D Plane in implicit form: ax + by + cz + d = 0\n */\nexport interface Plane3D {\n  a: number;  // Normal x component\n  b: number;  // Normal y component\n  c: number;  // Normal z component\n  d: number;  // Distance term (d = -dot(normal, pointOnPlane))\n}\n\nexport const Plane3D = {\n  /**\n   * Create a plane from a normal vector and a point on the plane\n   */\n  fromNormalAndPoint(normal: Vector3, point: Vector3): Plane3D {\n    const n = Vector3.normalize(normal);\n    const d = -Vector3.dot(n, point);\n    return { a: n[0], b: n[1], c: n[2], d };\n  },\n\n  /**\n   * Create a plane from three non-collinear points\n   * Uses counter-clockwise winding order: normal points toward viewer when\n   * p1 \u2192 p2 \u2192 p3 appears counter-clockwise\n   */\n  fromPoints(p1: Vector3, p2: Vector3, p3: Vector3): Plane3D {\n    const v1 = Vector3.subtract(p2, p1);\n    const v2 = Vector3.subtract(p3, p1);\n    const normal = Vector3.normalize(Vector3.cross(v1, v2));\n    return Plane3D.fromNormalAndPoint(normal, p1);\n  },\n\n  /**\n   * Create a plane directly from coefficients\n   */\n  create(a: number, b: number, c: number, d: number): Plane3D {\n    return { a, b, c, d };\n  },\n\n  /**\n   * Get the normal vector of the plane\n   */\n  normal(plane: Plane3D): Vector3 {\n    return [plane.a, plane.b, plane.c];\n  },\n\n  /**\n   * Signed distance from a point to the plane\n   * Positive = point is in front (on normal side)\n   * Negative = point is behind\n   * Zero = point is on the plane\n   */\n  signedDistance(point: Vector3, plane: Plane3D): number {\n    return plane.a * point[0] + plane.b * point[1] + plane.c * point[2] + plane.d;\n  },\n\n  /**\n   * Absolute distance from a point to the plane\n   */\n  distance(point: Vector3, plane: Plane3D): number {\n    return Math.abs(Plane3D.signedDistance(point, plane));\n  },\n\n  /**\n   * Classify a point relative to the plane\n   */\n  classifyPoint(point: Vector3, plane: Plane3D, epsilon: number = 1e-6): PointClassification {\n    const dist = Plane3D.signedDistance(point, plane);\n    if (dist > epsilon) return 'front';\n    if (dist < -epsilon) return 'back';\n    return 'on';\n  },\n\n  /**\n   * Check if a point is in front of the plane\n   */\n  isPointInFront(point: Vector3, plane: Plane3D, epsilon: number = 1e-6): boolean {\n    return Plane3D.signedDistance(point, plane) > epsilon;\n  },\n\n  /**\n   * Check if a point is behind the plane\n   */\n  isPointBehind(point: Vector3, plane: Plane3D, epsilon: number = 1e-6): boolean {\n    return Plane3D.signedDistance(point, plane) < -epsilon;\n  },\n\n  /**\n   * Check if a point is on the plane\n   */\n  isPointOn(point: Vector3, plane: Plane3D, epsilon: number = 1e-6): boolean {\n    return Math.abs(Plane3D.signedDistance(point, plane)) <= epsilon;\n  },\n\n  /**\n   * Mirror a point across the plane\n   * p' = p - 2 * signedDistance(p) * normal\n   */\n  mirrorPoint(point: Vector3, plane: Plane3D): Vector3 {\n    const dist = Plane3D.signedDistance(point, plane);\n    const normal = Plane3D.normal(plane);\n    return Vector3.subtract(point, Vector3.scale(normal, 2 * dist));\n  },\n\n  /**\n   * Mirror a plane across another plane (for fail plane propagation)\n   * This mirrors two points on the source plane and reconstructs.\n   */\n  mirrorPlane(planeToMirror: Plane3D, mirrorPlane: Plane3D): Plane3D {\n    const n = Plane3D.normal(planeToMirror);\n\n    // Find a point on planeToMirror\n    let p1: Vector3;\n    if (Math.abs(n[2]) > 0.5) {\n      p1 = [0, 0, -planeToMirror.d / planeToMirror.c];\n    } else if (Math.abs(n[1]) > 0.5) {\n      p1 = [0, -planeToMirror.d / planeToMirror.b, 0];\n    } else {\n      p1 = [-planeToMirror.d / planeToMirror.a, 0, 0];\n    }\n\n    // Second point offset along a tangent\n    const offset: Vector3 = Math.abs(n[0]) < 0.9 ? [1, 0, 0] : [0, 1, 0];\n    const tangent = Vector3.normalize(Vector3.cross(n, offset));\n    const p2 = Vector3.add(p1, tangent);\n\n    // Third point along bitangent\n    const bitangent = Vector3.cross(n, tangent);\n    const p3 = Vector3.add(p1, bitangent);\n\n    // Mirror all three points\n    const p1m = Plane3D.mirrorPoint(p1, mirrorPlane);\n    const p2m = Plane3D.mirrorPoint(p2, mirrorPlane);\n    const p3m = Plane3D.mirrorPoint(p3, mirrorPlane);\n\n    return Plane3D.fromPoints(p1m, p2m, p3m);\n  },\n\n  /**\n   * Flip the plane orientation (negate normal and d)\n   */\n  flip(plane: Plane3D): Plane3D {\n    return { a: -plane.a, b: -plane.b, c: -plane.c, d: -plane.d };\n  },\n\n  /**\n   * Ray-plane intersection\n   *\n   * Returns the t parameter along the ray where intersection occurs,\n   * or null if the ray is parallel to the plane.\n   *\n   * Point of intersection = rayOrigin + t * rayDirection\n   *\n   * @param rayOrigin - Starting point of the ray\n   * @param rayDirection - Direction of the ray (should be normalized for t to represent distance)\n   * @param plane - The plane to intersect with\n   */\n  rayIntersection(\n    rayOrigin: Vector3,\n    rayDirection: Vector3,\n    plane: Plane3D\n  ): number | null {\n    const normal = Plane3D.normal(plane);\n    const denom = Vector3.dot(normal, rayDirection);\n\n    if (Math.abs(denom) < 1e-10) {\n      return null; // Ray is parallel to plane\n    }\n\n    const t = -(Vector3.dot(normal, rayOrigin) + plane.d) / denom;\n    return t;\n  },\n\n  /**\n   * Get the point of intersection between a ray and plane\n   */\n  rayIntersectionPoint(\n    rayOrigin: Vector3,\n    rayDirection: Vector3,\n    plane: Plane3D\n  ): Vector3 | null {\n    const t = Plane3D.rayIntersection(rayOrigin, rayDirection, plane);\n    if (t === null) return null;\n    return Vector3.add(rayOrigin, Vector3.scale(rayDirection, t));\n  },\n\n  /**\n   * Project a point onto the plane\n   */\n  projectPoint(point: Vector3, plane: Plane3D): Vector3 {\n    const dist = Plane3D.signedDistance(point, plane);\n    const normal = Plane3D.normal(plane);\n    return Vector3.subtract(point, Vector3.scale(normal, dist));\n  },\n\n  /**\n   * Check if two planes are approximately equal\n   */\n  equals(a: Plane3D, b: Plane3D, epsilon: number = 1e-6): boolean {\n    // Planes are equal if normals are parallel and d values are equal (or negated)\n    const dotNormals = a.a * b.a + a.b * b.b + a.c * b.c;\n\n    if (Math.abs(dotNormals - 1) < epsilon) {\n      // Same orientation\n      return Math.abs(a.d - b.d) < epsilon;\n    }\n\n    if (Math.abs(dotNormals + 1) < epsilon) {\n      // Opposite orientation\n      return Math.abs(a.d + b.d) < epsilon;\n    }\n\n    return false;\n  },\n\n  /**\n   * Convert to string for debugging\n   */\n  toString(plane: Plane3D, precision: number = 4): string {\n    return `Plane3D(${plane.a.toFixed(precision)}x + ${plane.b.toFixed(precision)}y + ${plane.c.toFixed(precision)}z + ${plane.d.toFixed(precision)} = 0)`;\n  }\n};\n", "/**\n * 3D Polygon representation and operations for BeamTrace3D\n *\n * Polygons are convex and stored with counter-clockwise vertex winding\n * when viewed from the front (normal) side.\n */\n\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { PolygonClassification } from '../core/types';\n\n/**\n * Convex polygon in 3D space\n */\nexport interface Polygon3D {\n  vertices: Vector3[];    // Vertices in CCW winding order\n  plane: Plane3D;         // Supporting plane (computed from vertices)\n  materialId?: number;    // Optional material ID for acoustic properties\n}\n\nexport const Polygon3D = {\n  /**\n   * Create a polygon from vertices (computes plane automatically)\n   * Vertices must be in counter-clockwise order when viewed from front\n   */\n  create(vertices: Vector3[], materialId?: number): Polygon3D {\n    if (vertices.length < 3) {\n      throw new Error('Polygon requires at least 3 vertices');\n    }\n\n    // Clone vertices to prevent external mutation\n    const verts = vertices.map(v => Vector3.clone(v));\n    const plane = Plane3D.fromPoints(verts[0], verts[1], verts[2]);\n\n    return { vertices: verts, plane, materialId };\n  },\n\n  /**\n   * Create a polygon with an explicit plane (for split polygons that may be degenerate)\n   */\n  createWithPlane(vertices: Vector3[], plane: Plane3D, materialId?: number): Polygon3D {\n    if (vertices.length < 3) {\n      throw new Error('Polygon requires at least 3 vertices');\n    }\n    const verts = vertices.map(v => Vector3.clone(v));\n    return { vertices: verts, plane, materialId };\n  },\n\n  /**\n   * Get the number of vertices\n   */\n  vertexCount(poly: Polygon3D): number {\n    return poly.vertices.length;\n  },\n\n  /**\n   * Compute the centroid (geometric center) of the polygon\n   */\n  centroid(poly: Polygon3D): Vector3 {\n    const sum: Vector3 = [0, 0, 0];\n    for (const v of poly.vertices) {\n      sum[0] += v[0];\n      sum[1] += v[1];\n      sum[2] += v[2];\n    }\n    const n = poly.vertices.length;\n    return [sum[0] / n, sum[1] / n, sum[2] / n];\n  },\n\n  /**\n   * Compute the area of the polygon using cross product method\n   */\n  area(poly: Polygon3D): number {\n    if (poly.vertices.length < 3) return 0;\n\n    let total: Vector3 = [0, 0, 0];\n    const v0 = poly.vertices[0];\n\n    for (let i = 1; i < poly.vertices.length - 1; i++) {\n      const v1 = poly.vertices[i];\n      const v2 = poly.vertices[i + 1];\n      const cross = Vector3.cross(\n        Vector3.subtract(v1, v0),\n        Vector3.subtract(v2, v0)\n      );\n      total = Vector3.add(total, cross);\n    }\n\n    return 0.5 * Vector3.length(total);\n  },\n\n  /**\n   * Get the normal vector of the polygon (from the plane)\n   */\n  normal(poly: Polygon3D): Vector3 {\n    return Plane3D.normal(poly.plane);\n  },\n\n  /**\n   * Get edges as pairs of vertices [start, end]\n   */\n  edges(poly: Polygon3D): Array<[Vector3, Vector3]> {\n    const result: Array<[Vector3, Vector3]> = [];\n    for (let i = 0; i < poly.vertices.length; i++) {\n      const next = (i + 1) % poly.vertices.length;\n      result.push([poly.vertices[i], poly.vertices[next]]);\n    }\n    return result;\n  },\n\n  /**\n   * Classify the polygon relative to a plane\n   */\n  classify(poly: Polygon3D, plane: Plane3D, epsilon: number = 1e-6): PolygonClassification {\n    let front = 0;\n    let back = 0;\n\n    for (const v of poly.vertices) {\n      const classification = Plane3D.classifyPoint(v, plane, epsilon);\n      if (classification === 'front') front++;\n      else if (classification === 'back') back++;\n    }\n\n    if (front > 0 && back > 0) return 'spanning';\n    if (front > 0) return 'front';\n    if (back > 0) return 'back';\n    return 'coplanar';\n  },\n\n  /**\n   * Check if a point is inside the polygon\n   * Assumes the point is on (or very close to) the polygon's plane\n   */\n  containsPoint(poly: Polygon3D, point: Vector3, epsilon: number = 1e-6): boolean {\n    const normal = Plane3D.normal(poly.plane);\n    const n = poly.vertices.length;\n\n    for (let i = 0; i < n; i++) {\n      const v1 = poly.vertices[i];\n      const v2 = poly.vertices[(i + 1) % n];\n\n      const edge = Vector3.subtract(v2, v1);\n      const toPoint = Vector3.subtract(point, v1);\n      const cross = Vector3.cross(edge, toPoint);\n\n      // If cross product points opposite to normal, point is outside this edge\n      if (Vector3.dot(cross, normal) < -epsilon) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n   * Ray-polygon intersection\n   * Returns t parameter and intersection point, or null if no hit\n   */\n  rayIntersection(\n    rayOrigin: Vector3,\n    rayDirection: Vector3,\n    poly: Polygon3D\n  ): { t: number; point: Vector3 } | null {\n    const t = Plane3D.rayIntersection(rayOrigin, rayDirection, poly.plane);\n\n    if (t === null || t < 0) {\n      return null;\n    }\n\n    const point = Vector3.add(rayOrigin, Vector3.scale(rayDirection, t));\n\n    if (!Polygon3D.containsPoint(poly, point)) {\n      return null;\n    }\n\n    return { t, point };\n  },\n\n  /**\n   * Create a bounding box for the polygon\n   */\n  boundingBox(poly: Polygon3D): { min: Vector3; max: Vector3 } {\n    const min: Vector3 = [Infinity, Infinity, Infinity];\n    const max: Vector3 = [-Infinity, -Infinity, -Infinity];\n\n    for (const v of poly.vertices) {\n      min[0] = Math.min(min[0], v[0]);\n      min[1] = Math.min(min[1], v[1]);\n      min[2] = Math.min(min[2], v[2]);\n      max[0] = Math.max(max[0], v[0]);\n      max[1] = Math.max(max[1], v[1]);\n      max[2] = Math.max(max[2], v[2]);\n    }\n\n    return { min, max };\n  },\n\n  /**\n   * Check if polygon is degenerate (zero or near-zero area)\n   */\n  isDegenerate(poly: Polygon3D, areaThreshold: number = 1e-10): boolean {\n    return poly.vertices.length < 3 || Polygon3D.area(poly) < areaThreshold;\n  },\n\n  /**\n   * Flip the polygon winding (reverse vertex order and flip plane)\n   */\n  flip(poly: Polygon3D): Polygon3D {\n    const reversedVerts = [...poly.vertices].reverse();\n    const flippedPlane = Plane3D.flip(poly.plane);\n    return {\n      vertices: reversedVerts,\n      plane: flippedPlane,\n      materialId: poly.materialId\n    };\n  },\n\n  /**\n   * Clone a polygon\n   */\n  clone(poly: Polygon3D): Polygon3D {\n    return {\n      vertices: poly.vertices.map(v => Vector3.clone(v)),\n      plane: { ...poly.plane },\n      materialId: poly.materialId\n    };\n  },\n\n  /**\n   * Convert to string for debugging\n   */\n  toString(poly: Polygon3D): string {\n    const verts = poly.vertices.map(v => Vector3.toString(v, 2)).join(', ');\n    return `Polygon3D(${poly.vertices.length} vertices: [${verts}])`;\n  }\n};\n\n/**\n * Helper to create common room shapes\n */\nexport function createQuad(\n  p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3,\n  materialId?: number\n): Polygon3D {\n  return Polygon3D.create([p1, p2, p3, p4], materialId);\n}\n\n/**\n * Create a shoebox room (6 walls as polygons)\n * Origin is at one corner, room extends in positive x, y, z\n */\nexport function createShoeboxRoom(\n  width: number,   // x dimension\n  depth: number,   // y dimension\n  height: number,  // z dimension\n  floorMaterial?: number,\n  ceilingMaterial?: number,\n  wallMaterial?: number\n): Polygon3D[] {\n  // Corners\n  const v000: Vector3 = [0, 0, 0];\n  const v100: Vector3 = [width, 0, 0];\n  const v010: Vector3 = [0, depth, 0];\n  const v110: Vector3 = [width, depth, 0];\n  const v001: Vector3 = [0, 0, height];\n  const v101: Vector3 = [width, 0, height];\n  const v011: Vector3 = [0, depth, height];\n  const v111: Vector3 = [width, depth, height];\n\n  return [\n    // Floor (normal pointing up, CCW when viewed from above)\n    Polygon3D.create([v000, v100, v110, v010], floorMaterial),\n    // Ceiling (normal pointing down, CCW when viewed from below)\n    Polygon3D.create([v001, v011, v111, v101], ceilingMaterial),\n    // Front wall (y = 0, normal pointing +y)\n    Polygon3D.create([v000, v001, v101, v100], wallMaterial),\n    // Back wall (y = depth, normal pointing -y)\n    Polygon3D.create([v010, v110, v111, v011], wallMaterial),\n    // Left wall (x = 0, normal pointing +x)\n    Polygon3D.create([v000, v010, v011, v001], wallMaterial),\n    // Right wall (x = width, normal pointing -x)\n    Polygon3D.create([v100, v101, v111, v110], wallMaterial)\n  ];\n}\n", "/**\n * Polygon splitting for BSP tree construction\n *\n * Splits a polygon by a plane into front and back pieces.\n */\n\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { Polygon3D } from './polygon3d';\n\nexport interface SplitResult {\n  front: Polygon3D | null;\n  back: Polygon3D | null;\n}\n\n/**\n * Split a polygon by a plane\n *\n * Returns front and back pieces. Either may be null if the polygon\n * is entirely on one side of the plane.\n *\n * @param poly - The polygon to split\n * @param plane - The splitting plane\n * @param epsilon - Tolerance for point-on-plane classification\n */\nexport function splitPolygon(\n  poly: Polygon3D,\n  plane: Plane3D,\n  epsilon: number = 1e-6\n): SplitResult {\n  const classification = Polygon3D.classify(poly, plane, epsilon);\n\n  // Fast path: polygon entirely on one side\n  if (classification === 'front' || classification === 'coplanar') {\n    return { front: poly, back: null };\n  }\n  if (classification === 'back') {\n    return { front: null, back: poly };\n  }\n\n  // Polygon spans the plane - need to split\n  const frontVerts: Vector3[] = [];\n  const backVerts: Vector3[] = [];\n  const n = poly.vertices.length;\n\n  for (let i = 0; i < n; i++) {\n    const v1 = poly.vertices[i];\n    const v2 = poly.vertices[(i + 1) % n];\n\n    const d1 = Plane3D.signedDistance(v1, plane);\n    const d2 = Plane3D.signedDistance(v2, plane);\n\n    const c1 = d1 > epsilon ? 'front' : d1 < -epsilon ? 'back' : 'on';\n    const c2 = d2 > epsilon ? 'front' : d2 < -epsilon ? 'back' : 'on';\n\n    // Add v1 to appropriate list(s)\n    if (c1 === 'front') {\n      frontVerts.push(v1);\n    } else if (c1 === 'back') {\n      backVerts.push(v1);\n    } else {\n      // On the plane - add to both sides\n      frontVerts.push(v1);\n      backVerts.push(v1);\n    }\n\n    // Check if edge crosses the plane\n    if ((c1 === 'front' && c2 === 'back') || (c1 === 'back' && c2 === 'front')) {\n      // Compute intersection point\n      const t = d1 / (d1 - d2);\n      const intersection = Vector3.lerp(v1, v2, t);\n\n      // Add intersection to both sides\n      frontVerts.push(intersection);\n      backVerts.push(intersection);\n    }\n  }\n\n  // Create result polygons if they have at least 3 vertices\n  const front = frontVerts.length >= 3\n    ? Polygon3D.createWithPlane(frontVerts, poly.plane, poly.materialId)\n    : null;\n  const back = backVerts.length >= 3\n    ? Polygon3D.createWithPlane(backVerts, poly.plane, poly.materialId)\n    : null;\n\n  return { front, back };\n}\n\n/**\n * Split multiple polygons by a plane\n *\n * Useful for BSP tree construction where multiple polygons need to be\n * partitioned by the same splitting plane.\n */\nexport function splitPolygons(\n  polygons: Polygon3D[],\n  plane: Plane3D,\n  epsilon: number = 1e-6\n): { front: Polygon3D[]; back: Polygon3D[]; coplanar: Polygon3D[] } {\n  const front: Polygon3D[] = [];\n  const back: Polygon3D[] = [];\n  const coplanar: Polygon3D[] = [];\n\n  for (const poly of polygons) {\n    const classification = Polygon3D.classify(poly, plane, epsilon);\n\n    switch (classification) {\n      case 'coplanar':\n        coplanar.push(poly);\n        break;\n\n      case 'front':\n        front.push(poly);\n        break;\n\n      case 'back':\n        back.push(poly);\n        break;\n\n      case 'spanning': {\n        const { front: f, back: b } = splitPolygon(poly, plane, epsilon);\n        if (f) front.push(f);\n        if (b) back.push(b);\n        break;\n      }\n    }\n  }\n\n  return { front, back, coplanar };\n}\n", "/**\n * 3D Polygon clipping using Sutherland-Hodgman algorithm\n *\n * This is the critical algorithm for clipping polygons against beam boundaries.\n * Clips a polygon against one or more planes, keeping the portion on the\n * front (positive) side of each plane.\n */\n\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { Polygon3D } from './polygon3d';\n\n/**\n * Clip a polygon against a single plane using Sutherland-Hodgman algorithm\n *\n * Keeps the portion on the FRONT side of the plane (where signedDistance > 0)\n *\n * @param poly - The polygon to clip\n * @param plane - The clipping plane (normal points toward kept region)\n * @param epsilon - Tolerance for point-on-plane classification\n * @returns The clipped polygon, or null if entirely clipped away\n */\nexport function clipPolygonByPlane(\n  poly: Polygon3D,\n  plane: Plane3D,\n  epsilon: number = 1e-6\n): Polygon3D | null {\n  const input = poly.vertices;\n  const output: Vector3[] = [];\n\n  if (input.length < 3) return null;\n\n  for (let i = 0; i < input.length; i++) {\n    const current = input[i];\n    const next = input[(i + 1) % input.length];\n\n    const dCurrent = Plane3D.signedDistance(current, plane);\n    const dNext = Plane3D.signedDistance(next, plane);\n\n    // Inside = on front side of plane (dCurrent >= -epsilon)\n    const currentInside = dCurrent >= -epsilon;\n    const nextInside = dNext >= -epsilon;\n\n    if (currentInside) {\n      // Current vertex is inside - add it\n      output.push(current);\n    }\n\n    // Check for edge crossing\n    if ((currentInside && !nextInside) || (!currentInside && nextInside)) {\n      // Edge crosses the plane - compute intersection\n      const t = dCurrent / (dCurrent - dNext);\n      const intersection = Vector3.lerp(current, next, Math.max(0, Math.min(1, t)));\n      output.push(intersection);\n    }\n  }\n\n  if (output.length < 3) return null;\n\n  return Polygon3D.createWithPlane(output, poly.plane, poly.materialId);\n}\n\n/**\n * Clip a polygon against multiple planes (e.g., beam boundaries)\n *\n * The polygon must be on the front side of ALL planes to survive.\n * This is iterative Sutherland-Hodgman clipping.\n *\n * @param poly - The polygon to clip\n * @param planes - Array of clipping planes\n * @param epsilon - Tolerance for classification\n * @returns The clipped polygon, or null if entirely clipped away\n */\nexport function clipPolygonByPlanes(\n  poly: Polygon3D,\n  planes: Plane3D[],\n  epsilon: number = 1e-6\n): Polygon3D | null {\n  let current: Polygon3D | null = poly;\n\n  for (const plane of planes) {\n    if (!current) return null;\n    current = clipPolygonByPlane(current, plane, epsilon);\n  }\n\n  return current;\n}\n\n/**\n * Quick rejection test - check if polygon is entirely outside any clipping plane\n *\n * This is faster than full clipping when we only need to know if the result\n * would be non-empty.\n *\n * @param poly - The polygon to test\n * @param planes - Array of clipping planes\n * @param epsilon - Tolerance for classification\n * @returns true if polygon is entirely outside at least one plane\n */\nexport function quickRejectPolygon(\n  poly: Polygon3D,\n  planes: Plane3D[],\n  epsilon: number = 1e-6\n): boolean {\n  for (const plane of planes) {\n    let allBehind = true;\n    for (const v of poly.vertices) {\n      if (Plane3D.signedDistance(v, plane) >= -epsilon) {\n        allBehind = false;\n        break;\n      }\n    }\n    if (allBehind) {\n      return true; // Polygon is entirely behind this plane\n    }\n  }\n  return false;\n}\n\n/**\n * Check if a polygon potentially intersects a convex volume defined by planes\n *\n * Returns false if the polygon is definitely outside the volume.\n * Returns true if it might be inside (requires full clipping to confirm).\n *\n * @param poly - The polygon to test\n * @param planes - Array of planes defining the convex volume (normals point inward)\n * @param epsilon - Tolerance for classification\n */\nexport function polygonMayIntersectVolume(\n  poly: Polygon3D,\n  planes: Plane3D[],\n  epsilon: number = 1e-6\n): boolean {\n  // Polygon is definitely outside if all vertices are behind any single plane\n  return !quickRejectPolygon(poly, planes, epsilon);\n}\n\n/**\n * Clip a polygon against a frustum (beam volume)\n *\n * A frustum is defined by multiple boundary planes. For beam tracing,\n * this is typically N edge planes + 1 aperture plane.\n *\n * @param poly - The polygon to clip\n * @param frustumPlanes - Array of planes defining the frustum (normals point inward)\n * @param epsilon - Tolerance for classification\n * @returns The clipped polygon, or null if entirely outside the frustum\n */\nexport function clipPolygonByFrustum(\n  poly: Polygon3D,\n  frustumPlanes: Plane3D[],\n  epsilon: number = 1e-6\n): Polygon3D | null {\n  // Quick rejection first\n  if (quickRejectPolygon(poly, frustumPlanes, epsilon)) {\n    return null;\n  }\n\n  // Full clip\n  return clipPolygonByPlanes(poly, frustumPlanes, epsilon);\n}\n\n/**\n * Clip a ray segment against a convex volume defined by planes\n *\n * Returns the clipped segment [tMin, tMax] or null if ray misses the volume.\n *\n * @param rayOrigin - Start of the ray\n * @param rayDirection - Direction of the ray (normalized)\n * @param planes - Planes defining the convex volume (normals point inward)\n * @param tStart - Starting t value (default 0)\n * @param tEnd - Ending t value (default Infinity)\n */\nexport function clipRayByPlanes(\n  rayOrigin: Vector3,\n  rayDirection: Vector3,\n  planes: Plane3D[],\n  tStart: number = 0,\n  tEnd: number = Infinity\n): { tMin: number; tMax: number } | null {\n  let tMin = tStart;\n  let tMax = tEnd;\n\n  for (const plane of planes) {\n    const normal = Plane3D.normal(plane);\n    const denom = Vector3.dot(normal, rayDirection);\n    const dist = Plane3D.signedDistance(rayOrigin, plane);\n\n    if (Math.abs(denom) < 1e-10) {\n      // Ray parallel to plane\n      if (dist < 0) {\n        // Ray origin is behind the plane - ray is outside\n        return null;\n      }\n      // Ray origin is in front - continue\n      continue;\n    }\n\n    const t = -dist / denom;\n\n    if (denom > 0) {\n      // Ray is going in the direction of the normal\n      if (dist >= 0) {\n        // Starting in front, ray goes further in front - no exit through this plane\n        // (t would be negative, meaning the plane is behind us)\n        // No constraint needed\n      } else {\n        // Starting behind, ray will enter at t\n        tMin = Math.max(tMin, t);\n      }\n    } else {\n      // Ray is going against the normal (denom < 0)\n      if (dist >= 0) {\n        // Starting in front, ray goes toward the plane and will exit at t\n        tMax = Math.min(tMax, t);\n      } else {\n        // Starting behind, going further behind - ray never enters\n        return null;\n      }\n    }\n\n    if (tMin > tMax) {\n      return null; // Ray misses the volume\n    }\n  }\n\n  // Make sure tMax is positive (ray goes forward)\n  if (tMax < 0) {\n    return null;\n  }\n\n  // Clamp tMin to 0 if it's negative\n  tMin = Math.max(0, tMin);\n\n  if (tMin > tMax) {\n    return null;\n  }\n\n  return { tMin, tMax };\n}\n", "/**\n * 3D Binary Space Partitioning (BSP) Tree\n *\n * Used for accelerated ray-polygon intersection queries.\n * Provides O(log n) ray tracing instead of O(n) brute force.\n */\n\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { Polygon3D } from '../geometry/polygon3d';\nimport { splitPolygon } from '../geometry/polygon-split';\n\n/**\n * BSP tree node\n */\nexport interface BSPNode3D {\n  plane: Plane3D;              // Splitting plane (from the polygon)\n  polygon: Polygon3D;          // The polygon at this node\n  polygonId: number;           // Original polygon index\n  front: BSPNode3D | null;     // Subtree in front of plane\n  back: BSPNode3D | null;      // Subtree behind plane\n}\n\n/**\n * Result of a ray intersection query\n */\nexport interface RayHit3D {\n  t: number;                   // Parameter along ray\n  point: Vector3;              // Intersection point\n  polygonId: number;           // ID of hit polygon\n  polygon: Polygon3D;          // The hit polygon\n}\n\n/**\n * Polygon with its original index (for BSP construction)\n */\ninterface IndexedPolygon {\n  polygon: Polygon3D;\n  originalId: number;\n}\n\n/**\n * Build a BSP tree from an array of polygons\n *\n * @param polygons - Array of polygons to partition\n * @returns Root node of the BSP tree, or null if empty\n */\nexport function buildBSP(polygons: Polygon3D[]): BSPNode3D | null {\n  if (polygons.length === 0) return null;\n\n  // Create indexed polygons to track original IDs through splits\n  const indexed: IndexedPolygon[] = polygons.map((polygon, i) => ({\n    polygon,\n    originalId: i\n  }));\n\n  return buildBSPRecursive(indexed);\n}\n\n/**\n * Recursive BSP construction\n */\nfunction buildBSPRecursive(polygons: IndexedPolygon[]): BSPNode3D | null {\n  if (polygons.length === 0) return null;\n\n  // Choose splitting polygon using heuristic\n  const splitterIndex = chooseSplitter(polygons);\n  const splitter = polygons[splitterIndex];\n  const plane = splitter.polygon.plane;\n\n  const frontPolys: IndexedPolygon[] = [];\n  const backPolys: IndexedPolygon[] = [];\n\n  // Partition remaining polygons\n  for (let i = 0; i < polygons.length; i++) {\n    if (i === splitterIndex) continue;\n\n    const indexed = polygons[i];\n    const { front, back } = splitPolygon(indexed.polygon, plane);\n\n    // Preserve original ID through splits\n    if (front) {\n      frontPolys.push({ polygon: front, originalId: indexed.originalId });\n    }\n    if (back) {\n      backPolys.push({ polygon: back, originalId: indexed.originalId });\n    }\n  }\n\n  return {\n    plane,\n    polygon: splitter.polygon,\n    polygonId: splitter.originalId,\n    front: buildBSPRecursive(frontPolys),\n    back: buildBSPRecursive(backPolys)\n  };\n}\n\n/**\n * Choose the best splitting polygon using balance + split minimization heuristic\n *\n * The goal is to minimize:\n * 1. Number of polygon splits (expensive)\n * 2. Tree imbalance (affects query performance)\n */\nfunction chooseSplitter(polygons: IndexedPolygon[]): number {\n  if (polygons.length <= 3) return 0;\n\n  let bestIndex = 0;\n  let bestScore = Infinity;\n\n  // Sample a subset for large polygon counts\n  const sampleSize = Math.min(polygons.length, 10);\n  const step = Math.max(1, Math.floor(polygons.length / sampleSize));\n\n  for (let i = 0; i < polygons.length; i += step) {\n    const plane = polygons[i].polygon.plane;\n    let front = 0;\n    let back = 0;\n    let splits = 0;\n\n    for (let j = 0; j < polygons.length; j++) {\n      if (i === j) continue;\n\n      const classification = Polygon3D.classify(polygons[j].polygon, plane);\n      if (classification === 'front') {\n        front++;\n      } else if (classification === 'back') {\n        back++;\n      } else if (classification === 'spanning') {\n        front++;\n        back++;\n        splits++;\n      }\n      // coplanar polygons don't affect the score\n    }\n\n    // Score: heavily penalize splits, then minimize imbalance\n    const score = splits * 8 + Math.abs(front - back);\n    if (score < bestScore) {\n      bestScore = score;\n      bestIndex = i;\n    }\n  }\n\n  return bestIndex;\n}\n\n/**\n * Trace a ray through the BSP tree and find the first intersection\n *\n * @param origin - Ray origin point\n * @param direction - Ray direction (should be normalized for t to be distance)\n * @param node - BSP tree root node\n * @param tMin - Minimum t value to consider\n * @param tMax - Maximum t value to consider\n * @param ignoreId - Polygon ID to ignore (for avoiding self-intersection)\n * @returns First hit along the ray, or null if no hit\n */\nexport function rayTraceBSP(\n  origin: Vector3,\n  direction: Vector3,\n  node: BSPNode3D | null,\n  tMin: number = 0,\n  tMax: number = Infinity,\n  ignoreId: number = -1\n): RayHit3D | null {\n  if (!node) return null;\n\n  // Classify ray origin relative to splitting plane\n  const dOrigin = Plane3D.signedDistance(origin, node.plane);\n  const normal = Plane3D.normal(node.plane);\n  const dDir = Vector3.dot(normal, direction);\n\n  // Determine near and far subtrees based on ray origin position\n  let near: BSPNode3D | null;\n  let far: BSPNode3D | null;\n\n  if (dOrigin >= 0) {\n    near = node.front;\n    far = node.back;\n  } else {\n    near = node.back;\n    far = node.front;\n  }\n\n  // Calculate intersection with splitting plane\n  let tSplit: number | null = null;\n  if (Math.abs(dDir) > 1e-10) {\n    tSplit = -dOrigin / dDir;\n  }\n\n  let hit: RayHit3D | null = null;\n\n  if (tSplit === null || tSplit < tMin) {\n    // Ray parallel to plane or split point before ray start\n    // Ray stays entirely on near side\n    hit = rayTraceBSP(origin, direction, near, tMin, tMax, ignoreId);\n  } else if (tSplit > tMax) {\n    // Split point beyond ray end - ray stays on near side\n    hit = rayTraceBSP(origin, direction, near, tMin, tMax, ignoreId);\n  } else {\n    // Ray crosses the plane - check near side first\n    hit = rayTraceBSP(origin, direction, near, tMin, tSplit, ignoreId);\n\n    // If no hit in near subtree, check this node's polygon\n    if (!hit && node.polygonId !== ignoreId) {\n      const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n      if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n        hit = {\n          t: polyHit.t,\n          point: polyHit.point,\n          polygonId: node.polygonId,\n          polygon: node.polygon\n        };\n      }\n    }\n\n    // If still no hit, check far subtree\n    if (!hit) {\n      hit = rayTraceBSP(origin, direction, far, tSplit, tMax, ignoreId);\n    }\n  }\n\n  return hit;\n}\n\n/**\n * Check if a ray hits any polygon (occlusion test)\n *\n * Faster than rayTraceBSP when you only need to know if there's a hit,\n * not which polygon was hit.\n *\n * @param origin - Ray origin\n * @param direction - Ray direction\n * @param node - BSP tree root\n * @param tMin - Minimum t value\n * @param tMax - Maximum t value\n * @param ignoreId - Polygon ID to ignore\n * @returns true if ray hits something\n */\nexport function rayOccluded(\n  origin: Vector3,\n  direction: Vector3,\n  node: BSPNode3D | null,\n  tMin: number = 0,\n  tMax: number = Infinity,\n  ignoreId: number = -1\n): boolean {\n  return rayTraceBSP(origin, direction, node, tMin, tMax, ignoreId) !== null;\n}\n\n/**\n * Find all polygons intersected by a ray (not just the first)\n *\n * Useful for debugging or special effects.\n */\nexport function rayTraceAll(\n  origin: Vector3,\n  direction: Vector3,\n  node: BSPNode3D | null,\n  tMin: number = 0,\n  tMax: number = Infinity,\n  ignoreId: number = -1\n): RayHit3D[] {\n  const hits: RayHit3D[] = [];\n  rayTraceAllRecursive(origin, direction, node, tMin, tMax, ignoreId, hits);\n  // Sort by distance\n  hits.sort((a, b) => a.t - b.t);\n  return hits;\n}\n\nfunction rayTraceAllRecursive(\n  origin: Vector3,\n  direction: Vector3,\n  node: BSPNode3D | null,\n  tMin: number,\n  tMax: number,\n  ignoreId: number,\n  hits: RayHit3D[]\n): void {\n  if (!node) return;\n\n  const dOrigin = Plane3D.signedDistance(origin, node.plane);\n  const normal = Plane3D.normal(node.plane);\n  const dDir = Vector3.dot(normal, direction);\n\n  let near: BSPNode3D | null;\n  let far: BSPNode3D | null;\n\n  if (dOrigin >= 0) {\n    near = node.front;\n    far = node.back;\n  } else {\n    near = node.back;\n    far = node.front;\n  }\n\n  let tSplit: number | null = null;\n  if (Math.abs(dDir) > 1e-10) {\n    tSplit = -dOrigin / dDir;\n  }\n\n  // Check this node's polygon\n  if (node.polygonId !== ignoreId) {\n    const polyHit = Polygon3D.rayIntersection(origin, direction, node.polygon);\n    if (polyHit && polyHit.t >= tMin && polyHit.t <= tMax) {\n      hits.push({\n        t: polyHit.t,\n        point: polyHit.point,\n        polygonId: node.polygonId,\n        polygon: node.polygon\n      });\n    }\n  }\n\n  // Recurse into both subtrees\n  if (tSplit === null || tSplit < tMin) {\n    rayTraceAllRecursive(origin, direction, near, tMin, tMax, ignoreId, hits);\n  } else if (tSplit > tMax) {\n    rayTraceAllRecursive(origin, direction, near, tMin, tMax, ignoreId, hits);\n  } else {\n    rayTraceAllRecursive(origin, direction, near, tMin, tSplit, ignoreId, hits);\n    rayTraceAllRecursive(origin, direction, far, tSplit, tMax, ignoreId, hits);\n  }\n}\n\n/**\n * Count the total number of nodes in the BSP tree\n */\nexport function countNodes(node: BSPNode3D | null): number {\n  if (!node) return 0;\n  return 1 + countNodes(node.front) + countNodes(node.back);\n}\n\n/**\n * Calculate the maximum depth of the BSP tree\n */\nexport function treeDepth(node: BSPNode3D | null): number {\n  if (!node) return 0;\n  return 1 + Math.max(treeDepth(node.front), treeDepth(node.back));\n}\n", "/**\n * 3D Beam representation for BeamTrace3D\n *\n * A 3D beam is a polyhedral cone from a virtual source through an aperture polygon.\n * It is bounded by N+1 planes:\n * - N planes (one per aperture edge), with normals pointing INTO the beam\n * - 1 aperture plane, with normal pointing toward the source (INTO the beam)\n */\n\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { Polygon3D } from '../geometry/polygon3d';\n\n/**\n * 3D Beam - a polyhedral cone from virtual source through an aperture\n */\nexport interface Beam3D {\n  virtualSource: Vector3;          // The (possibly mirrored) source position\n  aperture: Polygon3D;             // The \"window\" polygon\n  boundaryPlanes: Plane3D[];       // All boundary planes (N edge + 1 aperture)\n  reflectingPolygonId: number;     // Which polygon this beam reflects off\n}\n\n/**\n * Information about which beam boundary was violated\n */\nexport interface BeamViolation {\n  plane: Plane3D;                  // The violated boundary plane\n  type: 'edge' | 'aperture';       // Type of boundary\n  index: number;                   // Index in boundaryPlanes array\n}\n\n/**\n * Construct boundary planes for a 3D beam\n *\n * All normals are oriented to point INTO the beam volume.\n * This means a point is inside the beam if it's on the front side\n * (positive signed distance) of all boundary planes.\n *\n * @param virtualSource - The virtual source position\n * @param aperture - The aperture polygon\n * @returns Array of boundary planes (N edge planes + 1 aperture plane)\n */\nexport function constructBeamBoundaryPlanes(\n  virtualSource: Vector3,\n  aperture: Polygon3D\n): Plane3D[] {\n  const planes: Plane3D[] = [];\n  const edges = Polygon3D.edges(aperture);\n  const apertureCentroid = Polygon3D.centroid(aperture);\n\n  // Create a plane for each edge of the aperture\n  // Each plane passes through the virtual source and the edge vertices\n  for (const [v1, v2] of edges) {\n    // Create plane through virtualSource, v1, v2\n    // The winding order determines the normal direction\n    let edgePlane = Plane3D.fromPoints(virtualSource, v1, v2);\n\n    // Ensure normal points INTO the beam (toward aperture centroid)\n    if (Plane3D.signedDistance(apertureCentroid, edgePlane) < 0) {\n      edgePlane = Plane3D.flip(edgePlane);\n    }\n\n    planes.push(edgePlane);\n  }\n\n  // Aperture plane - normal should point AWAY from source (toward the \"open\" side of beam)\n  // This allows polygons beyond the aperture to be considered inside the beam\n  let aperturePlane = aperture.plane;\n  if (Plane3D.signedDistance(virtualSource, aperturePlane) > 0) {\n    aperturePlane = Plane3D.flip(aperturePlane);\n  }\n  planes.push(aperturePlane);\n\n  return planes;\n}\n\n/**\n * Create a Beam3D from virtual source and aperture\n */\nexport function createBeam3D(\n  virtualSource: Vector3,\n  aperture: Polygon3D,\n  reflectingPolygonId: number\n): Beam3D {\n  return {\n    virtualSource,\n    aperture,\n    boundaryPlanes: constructBeamBoundaryPlanes(virtualSource, aperture),\n    reflectingPolygonId\n  };\n}\n\n/**\n * Check if a point is inside the beam volume\n *\n * A point is inside if it's on the front (positive) side of all boundary planes.\n *\n * @param point - The point to test\n * @param beam - The beam to test against\n * @param epsilon - Tolerance for boundary tests\n */\nexport function isPointInBeam(\n  point: Vector3,\n  beam: Beam3D,\n  epsilon: number = 1e-6\n): boolean {\n  for (const plane of beam.boundaryPlanes) {\n    if (Plane3D.signedDistance(point, plane) < -epsilon) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Find which boundary plane a point violates (if any)\n *\n * Returns null if the point is inside the beam.\n * Useful for fail plane detection - we want to know which boundary\n * caused the rejection.\n *\n * @param point - The point to test\n * @param beam - The beam to test against\n * @param epsilon - Tolerance for boundary tests\n */\nexport function findBeamViolation(\n  point: Vector3,\n  beam: Beam3D,\n  epsilon: number = 1e-6\n): BeamViolation | null {\n  const edgeCount = beam.boundaryPlanes.length - 1;\n\n  for (let i = 0; i < beam.boundaryPlanes.length; i++) {\n    const plane = beam.boundaryPlanes[i];\n    if (Plane3D.signedDistance(point, plane) < -epsilon) {\n      const type = i < edgeCount ? 'edge' : 'aperture';\n      return { plane, type, index: i };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get the minimum signed distance from a point to any beam boundary\n *\n * Positive means the point is inside by at least that distance.\n * Negative means the point is outside by that distance.\n */\nexport function distanceToBeamBoundary(\n  point: Vector3,\n  beam: Beam3D\n): number {\n  let minDist = Infinity;\n\n  for (const plane of beam.boundaryPlanes) {\n    const dist = Plane3D.signedDistance(point, plane);\n    minDist = Math.min(minDist, dist);\n  }\n\n  return minDist;\n}\n\n/**\n * Mirror a point across the reflecting polygon's plane\n * (Used to compute virtual sources)\n */\nexport function mirrorPointAcrossPolygon(\n  point: Vector3,\n  polygon: Polygon3D\n): Vector3 {\n  return Plane3D.mirrorPoint(point, polygon.plane);\n}\n\n/**\n * Check if a polygon is potentially visible to the beam\n *\n * Quick rejection test: polygon must not be entirely behind any boundary plane.\n *\n * @param polygon - The polygon to test\n * @param beam - The beam to test against\n * @param epsilon - Tolerance\n */\nexport function polygonMayBeInBeam(\n  polygon: Polygon3D,\n  beam: Beam3D,\n  epsilon: number = 1e-6\n): boolean {\n  for (const plane of beam.boundaryPlanes) {\n    let allBehind = true;\n\n    for (const v of polygon.vertices) {\n      if (Plane3D.signedDistance(v, plane) >= -epsilon) {\n        allBehind = false;\n        break;\n      }\n    }\n\n    if (allBehind) {\n      return false; // Polygon is entirely outside this boundary\n    }\n  }\n\n  return true;\n}\n\n/**\n * Check if the beam's virtual source can \"see\" a polygon\n * (Backface culling from virtual source's perspective)\n */\nexport function isPolygonFacingSource(\n  polygon: Polygon3D,\n  virtualSource: Vector3\n): boolean {\n  const centroid = Polygon3D.centroid(polygon);\n  const toSource = Vector3.subtract(virtualSource, centroid);\n  const normal = Plane3D.normal(polygon.plane);\n  return Vector3.dot(normal, toSource) > 0;\n}\n\n/**\n * Compute the solid angle subtended by the aperture from the virtual source\n * (Useful for importance sampling and energy calculations)\n */\nexport function beamSolidAngle(beam: Beam3D): number {\n  // Approximate solid angle using sum of triangular solid angles\n  const source = beam.virtualSource;\n  const verts = beam.aperture.vertices;\n  const n = verts.length;\n  let solidAngle = 0;\n\n  // Use first vertex as pivot for fan triangulation\n  for (let i = 1; i < n - 1; i++) {\n    const a = Vector3.normalize(Vector3.subtract(verts[0], source));\n    const b = Vector3.normalize(Vector3.subtract(verts[i], source));\n    const c = Vector3.normalize(Vector3.subtract(verts[i + 1], source));\n\n    // Compute solid angle of triangle using Oosterom-Strackee formula\n    const numerator = Math.abs(\n      Vector3.dot(a, Vector3.cross(b, c))\n    );\n    const denominator = 1 +\n      Vector3.dot(a, b) +\n      Vector3.dot(b, c) +\n      Vector3.dot(c, a);\n\n    solidAngle += 2 * Math.atan2(numerator, denominator);\n  }\n\n  return solidAngle;\n}\n", "/**\n * 3D Beam Tree for BeamTrace3D\n *\n * Hierarchical structure of beams representing all possible reflection paths\n * up to a maximum reflection order. Each node in the tree represents a\n * virtual source and aperture for a particular reflection sequence.\n */\n\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { Polygon3D } from '../geometry/polygon3d';\nimport { clipPolygonByPlanes, quickRejectPolygon } from '../geometry/clipping3d';\nimport { constructBeamBoundaryPlanes, isPolygonFacingSource, mirrorPointAcrossPolygon } from './beam3d';\nimport { FailPlaneType } from '../core/types';\n\n/**\n * Beam tree node representing a reflection from a polygon\n */\nexport interface BeamNode3D {\n  id: number;                      // Polygon ID (-1 for root/source)\n  parent: BeamNode3D | null;       // Parent node (null for root)\n  virtualSource: Vector3;          // Virtual source position for this reflection\n  aperture?: Polygon3D;            // Window polygon for this reflection\n  boundaryPlanes?: Plane3D[];      // Beam boundary planes\n  children: BeamNode3D[];          // Child beams (higher-order reflections)\n\n  // Optimization fields (populated during path finding)\n  failPlane?: Plane3D;             // Cached fail plane for this node\n  failPlaneType?: FailPlaneType;   // Type of failure\n}\n\n/**\n * Complete beam tree structure\n */\nexport interface BeamTree3D {\n  root: BeamNode3D;                // Root node (source position)\n  leafNodes: BeamNode3D[];         // All leaf nodes (for bucket optimization)\n  polygons: Polygon3D[];           // Reference to room polygons\n  maxReflectionOrder: number;      // Maximum reflections tracked\n}\n\n/**\n * Minimum aperture area to consider (skip tiny apertures)\n */\nconst MIN_APERTURE_AREA = 1e-6;\n\n/**\n * Build a complete beam tree from source and room geometry\n *\n * @param sourcePosition - Position of the sound source\n * @param polygons - Room polygons (walls, floor, ceiling)\n * @param maxReflectionOrder - Maximum number of reflections to track\n * @returns Complete beam tree structure\n */\nexport function buildBeamTree3D(\n  sourcePosition: Vector3,\n  polygons: Polygon3D[],\n  maxReflectionOrder: number\n): BeamTree3D {\n  // Create root node (source position, no reflection)\n  const root: BeamNode3D = {\n    id: -1,\n    parent: null,\n    virtualSource: Vector3.clone(sourcePosition),\n    children: []\n  };\n\n  // First order: source reflects off each visible polygon\n  // Only create first-order nodes if maxReflectionOrder >= 1\n  if (maxReflectionOrder >= 1) {\n    for (let i = 0; i < polygons.length; i++) {\n      const poly = polygons[i];\n\n      // Check if source can see this polygon (not backfacing)\n      if (!isPolygonFacingSource(poly, sourcePosition)) {\n        continue;\n      }\n\n      // Create virtual source by mirroring across polygon\n      const childVS = mirrorPointAcrossPolygon(sourcePosition, poly);\n\n      // First-order beam uses the full polygon as aperture\n      const childBoundaries = constructBeamBoundaryPlanes(childVS, poly);\n\n      const childNode: BeamNode3D = {\n        id: i,\n        parent: root,\n        virtualSource: childVS,\n        aperture: Polygon3D.clone(poly),\n        boundaryPlanes: childBoundaries,\n        children: []\n      };\n\n      root.children.push(childNode);\n\n      // Build higher-order reflections recursively\n      if (maxReflectionOrder > 1) {\n        buildBeamChildren(childNode, polygons, 2, maxReflectionOrder);\n      }\n    }\n  }\n\n  // Collect all leaf nodes for bucket optimization\n  const leafNodes: BeamNode3D[] = [];\n  collectLeafNodes(root, leafNodes);\n\n  return {\n    root,\n    leafNodes,\n    polygons,\n    maxReflectionOrder\n  };\n}\n\n/**\n * Recursively build child beams for higher-order reflections\n */\nfunction buildBeamChildren(\n  node: BeamNode3D,\n  polygons: Polygon3D[],\n  currentOrder: number,\n  maxOrder: number\n): void {\n  if (currentOrder > maxOrder) return;\n  if (!node.boundaryPlanes || !node.aperture) return;\n\n  for (let i = 0; i < polygons.length; i++) {\n    // Skip the polygon we just reflected off (can't reflect off same surface twice in a row)\n    if (i === node.id) continue;\n\n    const poly = polygons[i];\n\n    // Quick rejection: is polygon entirely outside beam?\n    if (quickRejectPolygon(poly, node.boundaryPlanes)) {\n      continue;\n    }\n\n    // Check if polygon is facing the virtual source (backface culling)\n    if (!isPolygonFacingSource(poly, node.virtualSource)) {\n      continue;\n    }\n\n    // Clip polygon to beam volume\n    const clipped = clipPolygonByPlanes(poly, node.boundaryPlanes);\n    if (!clipped) continue;\n\n    // Skip tiny apertures\n    const area = Polygon3D.area(clipped);\n    if (area < MIN_APERTURE_AREA) continue;\n\n    // Create child beam\n    const childVS = mirrorPointAcrossPolygon(node.virtualSource, poly);\n    const childBoundaries = constructBeamBoundaryPlanes(childVS, clipped);\n\n    const childNode: BeamNode3D = {\n      id: i,\n      parent: node,\n      virtualSource: childVS,\n      aperture: clipped,\n      boundaryPlanes: childBoundaries,\n      children: []\n    };\n\n    node.children.push(childNode);\n\n    // Continue recursion\n    if (currentOrder < maxOrder) {\n      buildBeamChildren(childNode, polygons, currentOrder + 1, maxOrder);\n    }\n  }\n}\n\n/**\n * Collect all leaf nodes (nodes with no children that have a valid aperture)\n */\nfunction collectLeafNodes(node: BeamNode3D, result: BeamNode3D[]): void {\n  if (node.children.length === 0 && node.id !== -1) {\n    result.push(node);\n  }\n  for (const child of node.children) {\n    collectLeafNodes(child, result);\n  }\n}\n\n/**\n * Collect all nodes at a specific reflection order\n */\nexport function collectNodesAtOrder(\n  tree: BeamTree3D,\n  order: number\n): BeamNode3D[] {\n  const result: BeamNode3D[] = [];\n  collectAtOrderRecursive(tree.root, 0, order, result);\n  return result;\n}\n\nfunction collectAtOrderRecursive(\n  node: BeamNode3D,\n  currentOrder: number,\n  targetOrder: number,\n  result: BeamNode3D[]\n): void {\n  if (currentOrder === targetOrder && node.id !== -1) {\n    result.push(node);\n    return;\n  }\n  if (currentOrder >= targetOrder) return;\n\n  for (const child of node.children) {\n    collectAtOrderRecursive(child, currentOrder + 1, targetOrder, result);\n  }\n}\n\n/**\n * Get the reflection order (depth) of a node\n */\nexport function getNodeOrder(node: BeamNode3D): number {\n  let order = 0;\n  let current: BeamNode3D | null = node;\n  while (current && current.id !== -1) {\n    order++;\n    current = current.parent;\n  }\n  return order;\n}\n\n/**\n * Get the reflection path (polygon IDs) from root to a node\n */\nexport function getReflectionPath(node: BeamNode3D): number[] {\n  const path: number[] = [];\n  let current: BeamNode3D | null = node;\n\n  while (current && current.id !== -1) {\n    path.unshift(current.id);\n    current = current.parent;\n  }\n\n  return path;\n}\n\n/**\n * Count total nodes in the beam tree\n */\nexport function countBeamNodes(tree: BeamTree3D): number {\n  return countNodesRecursive(tree.root);\n}\n\nfunction countNodesRecursive(node: BeamNode3D): number {\n  let count = 1;\n  for (const child of node.children) {\n    count += countNodesRecursive(child);\n  }\n  return count;\n}\n\n/**\n * Get statistics about the beam tree\n */\nexport interface BeamTreeStats {\n  totalNodes: number;\n  leafNodes: number;\n  maxDepth: number;\n  nodesPerOrder: number[];\n}\n\nexport function getBeamTreeStats(tree: BeamTree3D): BeamTreeStats {\n  const nodesPerOrder: number[] = [];\n  let maxDepth = 0;\n\n  function traverse(node: BeamNode3D, depth: number): void {\n    if (node.id !== -1) {\n      while (nodesPerOrder.length <= depth) {\n        nodesPerOrder.push(0);\n      }\n      nodesPerOrder[depth]++;\n      maxDepth = Math.max(maxDepth, depth);\n    }\n\n    for (const child of node.children) {\n      traverse(child, depth + 1);\n    }\n  }\n\n  traverse(tree.root, 0);\n\n  return {\n    totalNodes: countBeamNodes(tree),\n    leafNodes: tree.leafNodes.length,\n    maxDepth,\n    nodesPerOrder\n  };\n}\n\n/**\n * Clear all fail planes in the tree (reset optimization cache)\n */\nexport function clearFailPlanes(tree: BeamTree3D): void {\n  clearFailPlanesRecursive(tree.root);\n}\n\nfunction clearFailPlanesRecursive(node: BeamNode3D): void {\n  node.failPlane = undefined;\n  node.failPlaneType = undefined;\n  for (const child of node.children) {\n    clearFailPlanesRecursive(child);\n  }\n}\n\n/**\n * Iterate over all nodes in the tree (for batch operations)\n */\nexport function* iterateNodes(tree: BeamTree3D): Generator<BeamNode3D> {\n  yield* iterateNodesRecursive(tree.root);\n}\n\nfunction* iterateNodesRecursive(node: BeamNode3D): Generator<BeamNode3D> {\n  yield node;\n  for (const child of node.children) {\n    yield* iterateNodesRecursive(child);\n  }\n}\n", "/**\n * Fail Plane Optimization for BeamTrace3D\n *\n * The fail plane optimization caches the geometric reason why a path validation\n * failed, allowing O(1) rejection on subsequent frames when the listener moves.\n *\n * From the Laine et al. (2009) paper:\n * - Type 1 (polygon): Listener is behind the reflecting wall's plane\n * - Type 2 (beam): Listener is outside the beam volume (behind an edge plane)\n *\n * The fail plane is propagated (mirrored) through each reflection from the\n * detection node back to the leaf node for use in subsequent frames.\n */\n\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { Polygon3D } from '../geometry/polygon3d';\nimport { BeamNode3D } from '../structures/beamtree3d';\nimport { FailPlaneType } from '../core/types';\n\n/**\n * Information about a detected fail plane\n */\nexport interface FailPlaneInfo {\n  plane: Plane3D;             // The fail plane\n  type: FailPlaneType;        // Type of failure\n  nodeDepth: number;          // Depth at which failure was detected\n}\n\n/**\n * Detect fail plane for a listener position at a beam node\n *\n * This function determines which geometric constraint the listener violates,\n * and returns the corresponding fail plane.\n *\n * @param listenerPos - Current listener position\n * @param node - The beam node to check\n * @param polygons - Room polygons (for accessing the reflecting polygon)\n * @returns FailPlaneInfo if listener is outside, null if listener is valid\n */\nexport function detectFailPlane(\n  listenerPos: Vector3,\n  node: BeamNode3D,\n  polygons: Polygon3D[]\n): FailPlaneInfo | null {\n  if (!node.aperture || !node.boundaryPlanes) {\n    return null;\n  }\n\n  // Type 1: Check if listener is behind the reflecting polygon's plane\n  // The listener must be on the same side of the polygon as the virtual source\n  const reflectingPoly = polygons[node.id];\n  let polyPlane = reflectingPoly.plane;\n\n  // Orient plane so virtual source is in front\n  if (Plane3D.signedDistance(node.virtualSource, polyPlane) < 0) {\n    polyPlane = Plane3D.flip(polyPlane);\n  }\n\n  // If listener is behind the polygon plane, it can't receive reflections from this surface\n  if (Plane3D.signedDistance(listenerPos, polyPlane) < 0) {\n    return {\n      plane: polyPlane,\n      type: 'polygon',\n      nodeDepth: getNodeDepth(node)\n    };\n  }\n\n  // Type 2: Check beam boundaries\n  // Listener must be inside the beam volume (on front side of all boundary planes)\n  const edgeCount = node.boundaryPlanes.length - 1; // Last plane is aperture\n\n  for (let i = 0; i < node.boundaryPlanes.length; i++) {\n    const plane = node.boundaryPlanes[i];\n    if (Plane3D.signedDistance(listenerPos, plane) < 0) {\n      const type: FailPlaneType = i < edgeCount ? 'edge' : 'aperture';\n      return {\n        plane,\n        type,\n        nodeDepth: getNodeDepth(node)\n      };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Get the depth of a node in the beam tree\n */\nfunction getNodeDepth(node: BeamNode3D): number {\n  let depth = 0;\n  let current: BeamNode3D | null = node;\n  while (current && current.id !== -1) {\n    depth++;\n    current = current.parent;\n  }\n  return depth;\n}\n\n/**\n * Propagate a fail plane through the reflection chain\n *\n * When a fail plane is detected at some node, it needs to be mirrored\n * through each reflection surface to be valid for the leaf node.\n * This transforms the fail plane from the coordinate system at detection\n * to the coordinate system at the leaf.\n *\n * @param failPlane - The detected fail plane\n * @param fromNode - Node where failure was detected\n * @param toNode - Target node (usually leaf)\n * @param polygons - Room polygons for mirroring\n * @returns The propagated fail plane\n */\nexport function propagateFailPlane(\n  failPlane: Plane3D,\n  fromNode: BeamNode3D,\n  toNode: BeamNode3D,\n  polygons: Polygon3D[]\n): Plane3D {\n  let currentPlane = failPlane;\n  let current: BeamNode3D | null = fromNode;\n\n  // Walk from detection node toward root, mirroring at each reflection\n  while (current && current !== toNode && current.parent) {\n    if (current.id >= 0 && current.id < polygons.length) {\n      const reflectingPoly = polygons[current.id];\n      currentPlane = Plane3D.mirrorPlane(currentPlane, reflectingPoly.plane);\n    }\n    current = current.parent;\n  }\n\n  return currentPlane;\n}\n\n/**\n * Check if listener is still in the fail region (behind fail plane)\n *\n * This is the O(1) cache check that provides the speedup.\n * If the listener is behind the cached fail plane, we can skip\n * the expensive path validation.\n *\n * @param listenerPos - Current listener position\n * @param failPlane - Cached fail plane\n * @returns true if listener is behind the fail plane (path still invalid)\n */\nexport function isListenerBehindFailPlane(\n  listenerPos: Vector3,\n  failPlane: Plane3D\n): boolean {\n  return Plane3D.signedDistance(listenerPos, failPlane) < 0;\n}\n\n/**\n * Get the distance from listener to the fail plane\n *\n * Positive distance means listener is in front (valid side)\n * Negative distance means listener is behind (invalid side)\n *\n * This can be used to determine how far the listener needs to move\n * to potentially validate the path.\n */\nexport function distanceToFailPlane(\n  listenerPos: Vector3,\n  failPlane: Plane3D\n): number {\n  return Plane3D.signedDistance(listenerPos, failPlane);\n}\n\n/**\n * Find the minimum distance to any fail plane in a set of nodes\n *\n * Used by skip sphere optimization to determine sphere radius.\n */\nexport function minDistanceToFailPlanes(\n  listenerPos: Vector3,\n  nodes: BeamNode3D[]\n): number {\n  let minDist = Infinity;\n\n  for (const node of nodes) {\n    if (node.failPlane) {\n      const dist = Math.abs(Plane3D.signedDistance(listenerPos, node.failPlane));\n      minDist = Math.min(minDist, dist);\n    }\n  }\n\n  return minDist;\n}\n\n/**\n * Update fail plane for a node after path validation fails\n *\n * Detects the fail plane and caches it on the node for future checks.\n *\n * @param node - The node that failed validation\n * @param listenerPos - Current listener position\n * @param polygons - Room polygons\n * @returns true if a fail plane was detected and cached\n */\nexport function updateNodeFailPlane(\n  node: BeamNode3D,\n  listenerPos: Vector3,\n  polygons: Polygon3D[]\n): boolean {\n  const failInfo = detectFailPlane(listenerPos, node, polygons);\n\n  if (failInfo) {\n    node.failPlane = failInfo.plane;\n    node.failPlaneType = failInfo.type;\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Clear fail plane cache from a node\n */\nexport function clearNodeFailPlane(node: BeamNode3D): void {\n  node.failPlane = undefined;\n  node.failPlaneType = undefined;\n}\n\n/**\n * Check if a node has a cached fail plane\n */\nexport function hasFailPlane(node: BeamNode3D): boolean {\n  return node.failPlane !== undefined;\n}\n", "/**\n * Skip Sphere Optimization for BeamTrace3D\n *\n * The skip sphere optimization groups beam leaf nodes into buckets and\n * creates spatial rejection regions that allow skipping entire buckets\n * when the listener is inside the sphere.\n *\n * This is the 3D equivalent of the skip circle optimization from the\n * Laine et al. (2009) paper. When all paths in a bucket fail, a skip\n * sphere is created centered at the listener position with radius\n * equal to the minimum distance to any fail plane in the bucket.\n *\n * The paper found bucket size of 16 to be optimal for performance.\n */\n\nimport { Vector3 } from '../core/vector3';\nimport { Plane3D } from '../core/plane3d';\nimport { BeamNode3D } from '../structures/beamtree3d';\n\n/**\n * Skip sphere for bucket-level spatial rejection\n */\nexport interface SkipSphere {\n  center: Vector3;    // Listener position when bucket failed\n  radius: number;     // Minimum distance to any fail plane in bucket\n}\n\n/**\n * Bucket grouping beam leaf nodes for skip sphere optimization\n */\nexport interface Bucket3D {\n  id: number;                      // Bucket identifier\n  nodes: BeamNode3D[];             // Beam nodes in this bucket\n  skipSphere: SkipSphere | null;   // Current skip sphere (null if not set)\n}\n\n/**\n * Default bucket size (from paper: 16 nodes per bucket is optimal)\n */\nexport const DEFAULT_BUCKET_SIZE_3D = 16;\n\n/**\n * Create buckets from leaf nodes\n *\n * Nodes are grouped sequentially into buckets of the specified size.\n *\n * @param leafNodes - Array of leaf beam nodes\n * @param bucketSize - Number of nodes per bucket\n * @returns Array of buckets\n */\nexport function createBuckets3D(\n  leafNodes: BeamNode3D[],\n  bucketSize: number = DEFAULT_BUCKET_SIZE_3D\n): Bucket3D[] {\n  const buckets: Bucket3D[] = [];\n\n  for (let i = 0; i < leafNodes.length; i += bucketSize) {\n    buckets.push({\n      id: buckets.length,\n      nodes: leafNodes.slice(i, Math.min(i + bucketSize, leafNodes.length)),\n      skipSphere: null\n    });\n  }\n\n  return buckets;\n}\n\n/**\n * Check if a point is inside a skip sphere\n */\nexport function isInsideSkipSphere(\n  point: Vector3,\n  skipSphere: SkipSphere\n): boolean {\n  const dist = Vector3.distance(point, skipSphere.center);\n  return dist < skipSphere.radius;\n}\n\n/**\n * Skip sphere status for a bucket\n */\nexport type SkipSphereStatus = 'inside' | 'outside' | 'none';\n\n/**\n * Check skip sphere status for a bucket\n *\n * @param listenerPos - Current listener position\n * @param bucket - The bucket to check\n * @returns 'inside' if listener is inside skip sphere (can skip bucket),\n *          'outside' if listener escaped (must invalidate sphere),\n *          'none' if no skip sphere exists\n */\nexport function checkSkipSphere(\n  listenerPos: Vector3,\n  bucket: Bucket3D\n): SkipSphereStatus {\n  if (!bucket.skipSphere) {\n    return 'none';\n  }\n  return isInsideSkipSphere(listenerPos, bucket.skipSphere) ? 'inside' : 'outside';\n}\n\n/**\n * Create a skip sphere for a bucket where all paths failed\n *\n * The radius is the minimum distance to any fail plane in the bucket.\n * This ensures that as long as the listener stays inside the sphere,\n * it will still be behind all fail planes and all paths will still fail.\n *\n * @param listenerPos - Current listener position (center of sphere)\n * @param nodes - Nodes in the bucket (all should have fail planes)\n * @returns Skip sphere, or null if any node lacks a fail plane\n */\nexport function createSkipSphere(\n  listenerPos: Vector3,\n  nodes: BeamNode3D[]\n): SkipSphere | null {\n  let minDist = Infinity;\n\n  for (const node of nodes) {\n    if (!node.failPlane) {\n      // Can't create skip sphere if any node doesn't have a fail plane\n      return null;\n    }\n\n    // Distance to the fail plane (absolute value since we want sphere radius)\n    const dist = Math.abs(Plane3D.signedDistance(listenerPos, node.failPlane));\n    minDist = Math.min(minDist, dist);\n  }\n\n  // Don't create degenerate spheres\n  if (minDist === Infinity || minDist <= 1e-10) {\n    return null;\n  }\n\n  return {\n    center: Vector3.clone(listenerPos),\n    radius: minDist\n  };\n}\n\n/**\n * Invalidate a bucket's skip sphere\n *\n * Called when listener escapes the skip sphere.\n */\nexport function invalidateSkipSphere(bucket: Bucket3D): void {\n  bucket.skipSphere = null;\n}\n\n/**\n * Clear all fail planes in a bucket\n *\n * Called when skip sphere is invalidated to force re-evaluation.\n */\nexport function clearBucketFailPlanes(bucket: Bucket3D): void {\n  for (const node of bucket.nodes) {\n    node.failPlane = undefined;\n    node.failPlaneType = undefined;\n  }\n}\n\n/**\n * Update skip sphere for a bucket after processing\n *\n * If all paths in the bucket failed and all have fail planes,\n * create a skip sphere for future optimization.\n *\n * @param bucket - The bucket to update\n * @param listenerPos - Current listener position\n * @param allFailed - Whether all paths in bucket failed\n * @returns true if skip sphere was created\n */\nexport function updateBucketSkipSphere(\n  bucket: Bucket3D,\n  listenerPos: Vector3,\n  allFailed: boolean\n): boolean {\n  if (!allFailed) {\n    // At least one path succeeded, no skip sphere needed\n    return false;\n  }\n\n  // Check if all nodes have fail planes\n  for (const node of bucket.nodes) {\n    if (!node.failPlane) {\n      return false;\n    }\n  }\n\n  // Create skip sphere\n  bucket.skipSphere = createSkipSphere(listenerPos, bucket.nodes);\n  return bucket.skipSphere !== null;\n}\n\n/**\n * Process a bucket with skip sphere optimization\n *\n * Returns information about whether the bucket can be skipped\n * and whether it needs full processing.\n *\n * @param bucket - The bucket to process\n * @param listenerPos - Current listener position\n * @returns Processing decision\n */\nexport interface BucketProcessingResult {\n  skip: boolean;              // True if bucket can be skipped entirely\n  needsRevalidation: boolean; // True if fail planes need clearing\n}\n\nexport function processBucketSkipSphere(\n  bucket: Bucket3D,\n  listenerPos: Vector3\n): BucketProcessingResult {\n  const status = checkSkipSphere(listenerPos, bucket);\n\n  switch (status) {\n    case 'inside':\n      // Listener inside skip sphere - skip entire bucket\n      return { skip: true, needsRevalidation: false };\n\n    case 'outside':\n      // Listener escaped - need to invalidate and reprocess\n      invalidateSkipSphere(bucket);\n      clearBucketFailPlanes(bucket);\n      return { skip: false, needsRevalidation: true };\n\n    case 'none':\n    default:\n      // No skip sphere - normal processing\n      return { skip: false, needsRevalidation: false };\n  }\n}\n\n/**\n * Get statistics about skip sphere usage\n */\nexport interface SkipSphereStats {\n  totalBuckets: number;\n  bucketsWithSphere: number;\n  averageRadius: number;\n  minRadius: number;\n  maxRadius: number;\n}\n\nexport function getSkipSphereStats(buckets: Bucket3D[]): SkipSphereStats {\n  let bucketsWithSphere = 0;\n  let totalRadius = 0;\n  let minRadius = Infinity;\n  let maxRadius = 0;\n\n  for (const bucket of buckets) {\n    if (bucket.skipSphere) {\n      bucketsWithSphere++;\n      totalRadius += bucket.skipSphere.radius;\n      minRadius = Math.min(minRadius, bucket.skipSphere.radius);\n      maxRadius = Math.max(maxRadius, bucket.skipSphere.radius);\n    }\n  }\n\n  return {\n    totalBuckets: buckets.length,\n    bucketsWithSphere,\n    averageRadius: bucketsWithSphere > 0 ? totalRadius / bucketsWithSphere : 0,\n    minRadius: minRadius === Infinity ? 0 : minRadius,\n    maxRadius\n  };\n}\n", "/**\n * Optimized 3D Beam Tracing Solver\n *\n * Main solver that combines BSP tree, beam tree, fail plane, and skip sphere\n * optimizations for efficient acoustic path finding in 3D environments.\n *\n * Based on: Laine, S., Siltanen, S., Lokki, T., & Savioja, L. (2009).\n * \"Accelerated beam tracing algorithm.\" Applied Acoustics, 70(1), 172-181.\n */\n\nimport { Vector3 } from '../core/vector3';\nimport { PathPoint3D, ReflectionPath3D } from '../core/types';\nimport { Polygon3D } from '../geometry/polygon3d';\nimport { BSPNode3D, buildBSP, rayTraceBSP } from '../structures/bsp3d';\nimport { BeamTree3D, BeamNode3D, buildBeamTree3D, clearFailPlanes } from '../structures/beamtree3d';\nimport { detectFailPlane, isListenerBehindFailPlane } from '../optimization/failplane3d';\nimport {\n  Bucket3D,\n  createBuckets3D,\n  checkSkipSphere,\n  createSkipSphere,\n  invalidateSkipSphere,\n  clearBucketFailPlanes,\n  DEFAULT_BUCKET_SIZE_3D\n} from '../optimization/skipsphere3d';\n\n/**\n * Performance metrics for the solver\n */\nexport interface PerformanceMetrics3D {\n  totalLeafNodes: number;\n  bucketsTotal: number;\n  bucketsSkipped: number;\n  bucketsChecked: number;\n  failPlaneCacheHits: number;\n  failPlaneCacheMisses: number;\n  raycastCount: number;\n  skipSphereCount: number;\n  validPathCount: number;\n}\n\n/**\n * Configuration options for the solver\n */\nexport interface OptimizedSolver3DConfig {\n  maxReflectionOrder?: number;  // Maximum reflection order (default: 5)\n  bucketSize?: number;          // Nodes per bucket (default: 16)\n}\n\n/**\n * Data for visualizing a single beam cone\n */\nexport interface BeamVisualizationData {\n  virtualSource: Vector3;       // Virtual source position (apex of cone)\n  apertureVertices: Vector3[];  // Vertices of the aperture polygon\n  reflectionOrder: number;      // Reflection order (1 = first reflection)\n  polygonId: number;            // ID of the reflecting polygon\n}\n\n/**\n * Optimized 3D Beam Tracing Solver\n *\n * Provides efficient acoustic path finding using:\n * - BSP tree for O(log n) ray-polygon intersection\n * - Beam tree for reflection path enumeration\n * - Fail plane caching for O(1) early rejection\n * - Skip sphere bucketing for spatial acceleration\n */\nexport class OptimizedSolver3D {\n  private readonly polygons: Polygon3D[];\n  private readonly sourcePosition: Vector3;\n  private readonly bspRoot: BSPNode3D | null;\n  private readonly beamTree: BeamTree3D;\n  private readonly buckets: Bucket3D[];\n  private metrics: PerformanceMetrics3D;\n\n  /**\n   * Create a new 3D beam tracing solver\n   *\n   * @param polygons - Room geometry as an array of polygons\n   * @param sourcePosition - Position of the sound source\n   * @param config - Optional configuration\n   */\n  constructor(\n    polygons: Polygon3D[],\n    sourcePosition: Vector3,\n    config: OptimizedSolver3DConfig = {}\n  ) {\n    const maxOrder = config.maxReflectionOrder ?? 5;\n    const bucketSize = config.bucketSize ?? DEFAULT_BUCKET_SIZE_3D;\n\n    this.polygons = polygons;\n    this.sourcePosition = Vector3.clone(sourcePosition);\n\n    // Build BSP tree for ray tracing\n    this.bspRoot = buildBSP(polygons);\n\n    // Build beam tree for reflection enumeration\n    this.beamTree = buildBeamTree3D(sourcePosition, polygons, maxOrder);\n\n    // Create buckets for skip sphere optimization\n    this.buckets = createBuckets3D(this.beamTree.leafNodes, bucketSize);\n\n    // Initialize metrics\n    this.metrics = this.createEmptyMetrics();\n    this.metrics.totalLeafNodes = this.beamTree.leafNodes.length;\n    this.metrics.bucketsTotal = this.buckets.length;\n  }\n\n  /**\n   * Get all valid reflection paths from source to listener\n   *\n   * @param listenerPos - Position of the listener\n   * @returns Array of valid reflection paths\n   */\n  getPaths(listenerPos: Vector3): ReflectionPath3D[] {\n    this.resetMetrics();\n    const validPaths: ReflectionPath3D[] = [];\n\n    // 1. Check direct path (order 0)\n    const directPath = this.validateDirectPath(listenerPos);\n    if (directPath) {\n      validPaths.push(directPath);\n    }\n\n    // 2. Check intermediate reflection orders (non-leaf nodes)\n    const intermediatePaths = this.findIntermediatePaths(listenerPos, this.beamTree.root);\n    validPaths.push(...intermediatePaths);\n\n    // 3. Process leaf nodes with bucket optimization\n    for (const bucket of this.buckets) {\n      const skipStatus = checkSkipSphere(listenerPos, bucket);\n\n      if (skipStatus === 'inside') {\n        // Listener inside skip sphere - skip entire bucket\n        this.metrics.bucketsSkipped++;\n        continue;\n      }\n\n      if (skipStatus === 'outside') {\n        // Listener escaped - invalidate sphere and clear fail planes\n        invalidateSkipSphere(bucket);\n        clearBucketFailPlanes(bucket);\n      }\n\n      this.metrics.bucketsChecked++;\n\n      let allFailed = true;\n      let allHaveFailPlanes = true;\n\n      for (const node of bucket.nodes) {\n        // Check fail plane cache first (O(1))\n        if (node.failPlane && isListenerBehindFailPlane(listenerPos, node.failPlane)) {\n          this.metrics.failPlaneCacheHits++;\n          continue;\n        }\n\n        // Fail plane was invalidated or listener escaped\n        if (node.failPlane) {\n          node.failPlane = undefined;\n          node.failPlaneType = undefined;\n          this.metrics.failPlaneCacheMisses++;\n        }\n\n        // Full path validation\n        const result = this.validatePath(listenerPos, node);\n\n        if (result.valid && result.path) {\n          validPaths.push(result.path);\n          allFailed = false;\n          allHaveFailPlanes = false;\n        } else if (!node.failPlane) {\n          allHaveFailPlanes = false;\n        }\n      }\n\n      // Create skip sphere if all paths failed with fail planes\n      if (allFailed && allHaveFailPlanes && bucket.nodes.length > 0) {\n        bucket.skipSphere = createSkipSphere(listenerPos, bucket.nodes);\n        if (bucket.skipSphere) {\n          this.metrics.skipSphereCount++;\n        }\n      }\n    }\n\n    this.metrics.validPathCount = validPaths.length;\n    return validPaths;\n  }\n\n  /**\n   * Validate the direct path from listener to source\n   */\n  private validateDirectPath(listenerPos: Vector3): ReflectionPath3D | null {\n    const direction = Vector3.subtract(this.sourcePosition, listenerPos);\n    const dist = Vector3.length(direction);\n    const dir = Vector3.normalize(direction);\n\n    this.metrics.raycastCount++;\n    const hit = rayTraceBSP(listenerPos, dir, this.bspRoot, 0, dist, -1);\n\n    // If something blocks the path before reaching source, no direct path\n    if (hit && hit.t < dist - 1e-6) {\n      return null;\n    }\n\n    return [\n      { position: Vector3.clone(listenerPos), polygonId: null },\n      { position: Vector3.clone(this.sourcePosition), polygonId: null }\n    ];\n  }\n\n  /**\n   * Find paths through intermediate (non-leaf) nodes\n   *\n   * These are lower-order reflections that didn't spawn further children.\n   */\n  private findIntermediatePaths(listenerPos: Vector3, node: BeamNode3D): ReflectionPath3D[] {\n    const paths: ReflectionPath3D[] = [];\n\n    // Process children recursively\n    for (const child of node.children) {\n      if (child.children.length > 0) {\n        // Has children - recurse\n        paths.push(...this.findIntermediatePaths(listenerPos, child));\n      }\n    }\n\n    // Try this node if it has an aperture (is a reflection, not root)\n    if (node.id !== -1 && node.aperture) {\n      const path = this.traverseBeam(listenerPos, node);\n      if (path) {\n        paths.push(path);\n      }\n    }\n\n    return paths;\n  }\n\n  /**\n   * Traverse a beam from listener to source, building the reflection path\n   */\n  private traverseBeam(listenerPos: Vector3, node: BeamNode3D): ReflectionPath3D | null {\n    const pathPoints: PathPoint3D[] = [\n      { position: Vector3.clone(listenerPos), polygonId: null }\n    ];\n\n    let currentPoint = listenerPos;\n    let currentNode: BeamNode3D | null = node;\n    let prevPolyId = -1;\n\n    // Walk from leaf to root, finding reflection points\n    while (currentNode && currentNode.id !== -1) {\n      const poly = this.polygons[currentNode.id];\n      const imageSource = currentNode.virtualSource;\n\n      // Direction from current point toward virtual source\n      const dir = Vector3.normalize(Vector3.subtract(imageSource, currentPoint));\n\n      // Find intersection with reflecting polygon\n      const hit = Polygon3D.rayIntersection(currentPoint, dir, poly);\n\n      if (!hit) {\n        // Should intersect reflecting polygon - validation failure\n        return null;\n      }\n\n      // Check for occlusion between current point and reflection point\n      this.metrics.raycastCount++;\n      const occluder = rayTraceBSP(\n        currentPoint,\n        dir,\n        this.bspRoot,\n        1e-6,\n        hit.t - 1e-6,\n        prevPolyId\n      );\n\n      if (occluder) {\n        // Path is blocked\n        return null;\n      }\n\n      // Add reflection point to path\n      pathPoints.push({\n        position: Vector3.clone(hit.point),\n        polygonId: currentNode.id\n      });\n\n      currentPoint = hit.point;\n      prevPolyId = currentNode.id;\n      currentNode = currentNode.parent;\n    }\n\n    // Final segment to actual source\n    if (currentNode) {\n      const dir = Vector3.normalize(\n        Vector3.subtract(currentNode.virtualSource, currentPoint)\n      );\n      const dist = Vector3.distance(currentNode.virtualSource, currentPoint);\n\n      this.metrics.raycastCount++;\n      const finalHit = rayTraceBSP(\n        currentPoint,\n        dir,\n        this.bspRoot,\n        1e-6,\n        dist - 1e-6,\n        prevPolyId\n      );\n\n      if (finalHit) {\n        // Final segment is blocked\n        return null;\n      }\n\n      // Add source point\n      pathPoints.push({\n        position: Vector3.clone(currentNode.virtualSource),\n        polygonId: null\n      });\n    }\n\n    return pathPoints;\n  }\n\n  /**\n   * Validate a path through a beam node\n   */\n  private validatePath(\n    listenerPos: Vector3,\n    leafNode: BeamNode3D\n  ): { valid: boolean; path: ReflectionPath3D | null } {\n    const path = this.traverseBeam(listenerPos, leafNode);\n\n    if (path) {\n      return { valid: true, path };\n    }\n\n    // Path failed - try to detect and cache fail plane\n    const failInfo = detectFailPlane(listenerPos, leafNode, this.polygons);\n    if (failInfo) {\n      leafNode.failPlane = failInfo.plane;\n      leafNode.failPlaneType = failInfo.type;\n    }\n\n    return { valid: false, path: null };\n  }\n\n  /**\n   * Get performance metrics from the last getPaths() call\n   */\n  getMetrics(): PerformanceMetrics3D {\n    return { ...this.metrics };\n  }\n\n  /**\n   * Clear all cached fail planes and skip spheres\n   *\n   * Call this if the room geometry changes.\n   */\n  clearCache(): void {\n    clearFailPlanes(this.beamTree);\n    for (const bucket of this.buckets) {\n      invalidateSkipSphere(bucket);\n    }\n  }\n\n  /**\n   * Get the number of leaf nodes in the beam tree\n   */\n  getLeafNodeCount(): number {\n    return this.beamTree.leafNodes.length;\n  }\n\n  /**\n   * Get the maximum reflection order\n   */\n  getMaxReflectionOrder(): number {\n    return this.beamTree.maxReflectionOrder;\n  }\n\n  /**\n   * Get the source position\n   */\n  getSourcePosition(): Vector3 {\n    return Vector3.clone(this.sourcePosition);\n  }\n\n  /**\n   * Get beam data for visualization\n   * Returns beams organized by reflection order\n   */\n  getBeamsForVisualization(maxOrder?: number): BeamVisualizationData[] {\n    const beams: BeamVisualizationData[] = [];\n    const effectiveMaxOrder = maxOrder ?? this.beamTree.maxReflectionOrder;\n\n    const traverse = (node: BeamNode3D, order: number) => {\n      if (order > effectiveMaxOrder) return;\n\n      if (node.id !== -1 && node.aperture) {\n        beams.push({\n          virtualSource: Vector3.clone(node.virtualSource),\n          apertureVertices: node.aperture.vertices.map(v => Vector3.clone(v)),\n          reflectionOrder: order,\n          polygonId: node.id\n        });\n      }\n\n      for (const child of node.children) {\n        traverse(child, order + 1);\n      }\n    };\n\n    traverse(this.beamTree.root, 0);\n    return beams;\n  }\n\n  /**\n   * Create empty metrics object\n   */\n  private createEmptyMetrics(): PerformanceMetrics3D {\n    return {\n      totalLeafNodes: 0,\n      bucketsTotal: 0,\n      bucketsSkipped: 0,\n      bucketsChecked: 0,\n      failPlaneCacheHits: 0,\n      failPlaneCacheMisses: 0,\n      raycastCount: 0,\n      skipSphereCount: 0,\n      validPathCount: 0\n    };\n  }\n\n  /**\n   * Reset metrics for a new getPaths() call\n   */\n  private resetMetrics(): void {\n    const total = this.metrics.totalLeafNodes;\n    const buckets = this.metrics.bucketsTotal;\n    this.metrics = this.createEmptyMetrics();\n    this.metrics.totalLeafNodes = total;\n    this.metrics.bucketsTotal = buckets;\n  }\n}\n\n/**\n * Compute the total path length of a reflection path\n */\nexport function computePathLength(path: ReflectionPath3D): number {\n  let length = 0;\n  for (let i = 1; i < path.length; i++) {\n    length += Vector3.distance(path[i - 1].position, path[i].position);\n  }\n  return length;\n}\n\n/**\n * Compute arrival time for a path (assuming speed of sound)\n */\nexport function computeArrivalTime(\n  path: ReflectionPath3D,\n  speedOfSound: number = 343\n): number {\n  return computePathLength(path) / speedOfSound;\n}\n\n/**\n * Get the reflection order of a path (number of reflections)\n */\nexport function getPathReflectionOrder(path: ReflectionPath3D): number {\n  // Count points with non-null polygonId (reflection points)\n  return path.filter(p => p.polygonId !== null).length;\n}\n", "/**\n * BeamTrace3D - 3D Beam Tracing for Acoustic Simulations\n *\n * Main entry point for the 3D beam tracing library.\n * Extends the 2D BeamTrace implementation to full 3D with:\n * - 3D polygonal room geometry\n * - BSP tree acceleration\n * - Fail plane caching\n * - Skip sphere bucketing\n *\n * Based on: Laine, S., Siltanen, S., Lokki, T., & Savioja, L. (2009).\n * \"Accelerated beam tracing algorithm.\" Applied Acoustics, 70(1), 172-181.\n *\n * @example\n * ```typescript\n * import { Polygon3D, Source3D, Listener3D, Solver3D, createShoeboxRoom } from './beamtrace3d';\n *\n * // Create a simple room\n * const room = createShoeboxRoom(10, 8, 3);\n *\n * // Create source and solver\n * const source = new Source3D([5, 4, 1.5]);\n * const solver = new Solver3D(room, source, { maxReflectionOrder: 4 });\n *\n * // Find paths to listener\n * const listener = new Listener3D([2, 2, 1.2]);\n * const paths = solver.getPaths(listener.position);\n * ```\n */\n\n// Core types\nexport { Vector3 } from './core/vector3';\nexport { Plane3D } from './core/plane3d';\nexport type {\n  Point3D,\n  PathPoint3D,\n  ReflectionPath3D,\n  PointClassification,\n  PolygonClassification,\n  FailPlaneType\n} from './core/types';\n\n// Geometry\nexport { Polygon3D, createShoeboxRoom, createQuad } from './geometry/polygon3d';\nexport { splitPolygon, splitPolygons } from './geometry/polygon-split';\nexport {\n  clipPolygonByPlane,\n  clipPolygonByPlanes,\n  clipPolygonByFrustum,\n  quickRejectPolygon,\n  polygonMayIntersectVolume,\n  clipRayByPlanes\n} from './geometry/clipping3d';\n\n// Structures\nexport { buildBSP, rayTraceBSP, rayOccluded, rayTraceAll, countNodes, treeDepth } from './structures/bsp3d';\nexport type { BSPNode3D, RayHit3D } from './structures/bsp3d';\n\nexport {\n  createBeam3D,\n  constructBeamBoundaryPlanes,\n  isPointInBeam,\n  findBeamViolation,\n  distanceToBeamBoundary,\n  mirrorPointAcrossPolygon,\n  polygonMayBeInBeam,\n  isPolygonFacingSource,\n  beamSolidAngle\n} from './structures/beam3d';\nexport type { Beam3D, BeamViolation } from './structures/beam3d';\n\nexport {\n  buildBeamTree3D,\n  collectNodesAtOrder,\n  getNodeOrder,\n  getReflectionPath,\n  countBeamNodes,\n  getBeamTreeStats,\n  clearFailPlanes,\n  iterateNodes\n} from './structures/beamtree3d';\nexport type { BeamNode3D, BeamTree3D, BeamTreeStats } from './structures/beamtree3d';\n\n// Optimization\nexport {\n  detectFailPlane,\n  propagateFailPlane,\n  isListenerBehindFailPlane,\n  distanceToFailPlane,\n  minDistanceToFailPlanes,\n  updateNodeFailPlane,\n  clearNodeFailPlane,\n  hasFailPlane\n} from './optimization/failplane3d';\nexport type { FailPlaneInfo } from './optimization/failplane3d';\n\nexport {\n  createBuckets3D,\n  isInsideSkipSphere,\n  checkSkipSphere,\n  createSkipSphere,\n  invalidateSkipSphere,\n  clearBucketFailPlanes,\n  updateBucketSkipSphere,\n  processBucketSkipSphere,\n  getSkipSphereStats,\n  DEFAULT_BUCKET_SIZE_3D\n} from './optimization/skipsphere3d';\nexport type { SkipSphere, Bucket3D, SkipSphereStatus, BucketProcessingResult, SkipSphereStats } from './optimization/skipsphere3d';\n\n// Solver\nexport {\n  OptimizedSolver3D,\n  computePathLength,\n  computeArrivalTime,\n  getPathReflectionOrder\n} from './solver/solver3d';\nexport type { PerformanceMetrics3D, OptimizedSolver3DConfig, BeamVisualizationData } from './solver/solver3d';\n\n// Convenience aliases\nimport { Vector3 } from './core/vector3';\nimport { Polygon3D, createShoeboxRoom } from './geometry/polygon3d';\nimport { OptimizedSolver3D, OptimizedSolver3DConfig, BeamVisualizationData } from './solver/solver3d';\nimport type { ReflectionPath3D } from './core/types';\n\n/**\n * 3D Sound source\n */\nexport class Source3D {\n  public readonly position: Vector3;\n\n  constructor(position: Vector3) {\n    this.position = Vector3.clone(position);\n  }\n}\n\n/**\n * 3D Listener\n */\nexport class Listener3D {\n  public position: Vector3;\n\n  constructor(position: Vector3) {\n    this.position = Vector3.clone(position);\n  }\n\n  /**\n   * Update listener position\n   */\n  moveTo(position: Vector3): void {\n    this.position = Vector3.clone(position);\n  }\n}\n\n/**\n * Main 3D Solver class (alias for OptimizedSolver3D with simpler interface)\n */\nexport class Solver3D {\n  private readonly solver: OptimizedSolver3D;\n  public readonly source: Source3D;\n\n  constructor(\n    polygons: Polygon3D[],\n    source: Source3D,\n    config?: OptimizedSolver3DConfig\n  ) {\n    this.source = source;\n    this.solver = new OptimizedSolver3D(polygons, source.position, config);\n  }\n\n  /**\n   * Get all valid reflection paths to a listener\n   */\n  getPaths(listener: Listener3D | Vector3): ReflectionPath3D[] {\n    const pos = Array.isArray(listener) ? listener : listener.position;\n    return this.solver.getPaths(pos);\n  }\n\n  /**\n   * Get performance metrics from last getPaths() call\n   */\n  getMetrics() {\n    return this.solver.getMetrics();\n  }\n\n  /**\n   * Clear optimization caches\n   */\n  clearCache(): void {\n    this.solver.clearCache();\n  }\n\n  /**\n   * Get number of leaf nodes in beam tree\n   */\n  getLeafNodeCount(): number {\n    return this.solver.getLeafNodeCount();\n  }\n\n  /**\n   * Get maximum reflection order\n   */\n  getMaxReflectionOrder(): number {\n    return this.solver.getMaxReflectionOrder();\n  }\n\n  /**\n   * Get beam data for visualization\n   */\n  getBeamsForVisualization(maxOrder?: number): BeamVisualizationData[] {\n    return this.solver.getBeamsForVisualization(maxOrder);\n  }\n}\n\n/**\n * Create a simple shoebox room for testing\n */\nexport function createRoom(width: number, depth: number, height: number): Polygon3D[] {\n  return createShoeboxRoom(width, depth, height);\n}\n"],
  "mappings": "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",
  "names": ["floorMaterial", "listenerPos", "listenerPos", "listenerPos", "listenerPos", "source", "listener", "gridHelper"]
}
